var documenterSearchIndex = {"docs":
[{"location":"module_index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [GuidedProposals]","category":"page"},{"location":"module_index/#GuidedProposals.F-Tuple{GuidProp,Any}","page":"Index","title":"GuidedProposals.F","text":"F(P::GuidProp, i)\n\nReturn saved vector Fi.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.F-Tuple{GuidedProposals.HFcSolver,Integer}","page":"Index","title":"GuidedProposals.F","text":"F(s::HFcSolver, i::Integer)\n\nReturn saved vector Fi.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.H-Tuple{GuidProp,Any}","page":"Index","title":"GuidedProposals.H","text":"H(P::GuidProp, i)\n\nReturn saved matrix Hi.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.H-Tuple{GuidedProposals.HFcSolver,Integer}","page":"Index","title":"GuidedProposals.H","text":"H(s::HFcSolver, i::Integer)\n\nReturn saved matrix Hi.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.build_guid_prop-Tuple{AbstractArray,NamedTuple,Array{T,1} where T,Any,Any}","page":"Index","title":"GuidedProposals.build_guid_prop","text":"build_guid_prop(\n    aux_laws::AbstractArray, recording::NamedTuple, tts::Vector, args, kwargs\n)\n\nSame as a version with ::Type{AuxLaw}, but aux_laws is a list of auxiliary laws that correspond to each inter-observation interval.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.build_guid_prop-Union{Tuple{AuxLaw}, Tuple{Type{AuxLaw},NamedTuple,Array{T,1} where T,Vararg{Any,N} where N}} where AuxLaw<:DiffusionDefinition.DiffusionProcess","page":"Index","title":"GuidedProposals.build_guid_prop","text":"build_guid_prop(\n    ::Type{AuxLaw}, recording::NamedTuple, tts::Vector, args...; kwargs...\n) where {AuxLaw <: DD.DiffusionProcess}\n\nInitialize multiple instances of GuidProp corresponding to guided proposals for observations stored in recording. The time grids for each inter-observation interval is given in tts and AuxLaw is the auxiliary law for creating guided proposals. args... are passed to each constructor of GuidProp.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.c-Tuple{GuidProp,Any}","page":"Index","title":"GuidedProposals.c","text":"c(P::GuidProp, i)\n\nReturn saved scalar ci.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.c-Tuple{GuidedProposals.HFcSolver,Integer}","page":"Index","title":"GuidedProposals.c","text":"c(s::HFcSolver, i::Integer)\n\nReturn saved scalar ci.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.guid_prop_for_blocking-Union{Tuple{GuidProp{K,DP,DW,SS,R,R2,O,S,T}}, Tuple{T}, Tuple{S}, Tuple{O}, Tuple{R2}, Tuple{R}, Tuple{SS}, Tuple{DW}, Tuple{DP}, Tuple{K}, Tuple{GuidProp{K,DP,DW,SS,R,R2,O,S,T},Any}, Tuple{GuidProp{K,DP,DW,SS,R,R2,O,S,T},Any,Any}, Tuple{GuidProp{K,DP,DW,SS,R,R2,O,S,T},Any,Any,Any}} where T where S where O where R2 where R where SS where DW where DP where K","page":"Index","title":"GuidedProposals.guid_prop_for_blocking","text":"guid_prop_for_blocking(\n    P::GuidProp,\n    AuxLaw=remove_curly(R2),\n    artificial_noise=1e-11,\n    solver_choice=(\n        solver=Tsit5(),\n        ode_type=:HFc,\n        convert_to_HFc=false,\n        mode=:outofplace,\n        gradients=false,\n        eltype=Float64,\n    )\n)\n\nInitializer for GuidProp struct when doing blocking. It is used to initialize a GuidProp on the last interval of each block. It uses an existing GuidProp instance P from a no-blocking scheme as a template for parameter values and uses a new auxiliary law AuxLaw that is adjusted for the fact that the terminal observation is observed exactly. artificial_noise is added to the exact observation for the numerical purposes. solver choices works as with GuidProp initializer.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.loglikhd_obs-Tuple{GuidProp,Any}","page":"Index","title":"GuidedProposals.loglikhd_obs","text":"loglikhd_obs(P::GuidProp, x0)\n\nCompute the contribution of end-points to the log-likelihood function, i.e.: logrho(tx).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.recompute_guiding_term!","page":"Index","title":"GuidedProposals.recompute_guiding_term!","text":"recompute_guiding_term!(P::GuidProp, next_guided_prop=nothing)\n\nRecompute the guiding term (most often used after update of parameters or change of an observation). next_guided_prop is the guided proposal law from the subsequent interval\n\n\n\n\n\n","category":"function"},{"location":"module_index/#GuidedProposals.recompute_guiding_term!-Tuple{AbstractArray{#s15,N} where N where #s15<:GuidProp}","page":"Index","title":"GuidedProposals.recompute_guiding_term!","text":"recompute_guiding_term!(PP::Vector{<:GuidProp})\n\nRecompute the guiding term for the entire trajectory with all observations (most often used after update of parameters or change of an observation).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.standard_guid_prop_time_transf-Tuple{Any}","page":"Index","title":"GuidedProposals.standard_guid_prop_time_transf","text":"standard_guid_prop_time_transf(tt)\n\nStandard time transformation used for guided proposals:\n\nτ t  t_0 + (t-t_0)left2 - frac(t-t_0)T-t_0right\n\napplied to a vector tt where t_0=tt[1] and T=tt[end]\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.AbstractGuidingTermSolver","page":"Index","title":"GuidedProposals.AbstractGuidingTermSolver","text":"AbstractGuidingTermSolver{Tmode}\n\nSupertype for ODE solvers (solving H,F,c system or M,L,μ system or P,ν system). Tmode is a flag for whether computations are done in-place (with states represented by vectors), out-of-place (with state represented by StaticArrays), or on GPUs (with states represented by cuArrays).\n\n\n\n\n\n","category":"type"},{"location":"module_index/#GuidedProposals.HFcBuffer","page":"Index","title":"GuidedProposals.HFcBuffer","text":"struct HFcBuffer{\n        T,D,TB,Tβ,Tσ,Ta,Tmat,Tvec\n        } <: DiffusionDefinition.AbstractBuffer{T}\n    data::Vector{T}\n    B::TB\n    β::Tβ\n    σ::Tσ\n    a::Ta\n    mat::Tmat\n    vec::Tvec\nend\n\nA buffer for temporary computations of in-place ODE solvers solving for H,F,c system.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#GuidedProposals.HFcContainer","page":"Index","title":"GuidedProposals.HFcContainer","text":"struct HFcContainer{T,D,TH,TF,Tc} <: AbstractBuffer{T}\n    data::Vector{T}\n    H::TH\n    F::TF\n    c::Tc\nend\n\nA buffer containing data for in-place computations of H,F,c terms.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#GuidedProposals.HFcSolver","page":"Index","title":"GuidedProposals.HFcSolver","text":"struct HFcSolver{Tmode,Tsv,Tps,Tcb,Ts,T,Ta} <: AbstractGuidingTermSolver{Tmode}\n    saved_values::Tsv\n    problem_setup::Tps\n    callback::Tcb\n    solver::Ts\n    HFc0::T\n    access::Ta\nend\n\nStruct for solving a (H,F,c)-system of ODEs.\n\n    HFcSolver(\n        ::Val{:inplace},\n        tt,\n        xT_plus,\n        P,\n        obs,\n        choices,\n    )\nConstructor for an ODE solver with in-place operations. Pre-allocates space\nand solves a (H,F,c)-system of ODEs once, backward in time on the interval\n`(tt[1], tt[end])`, with a terminal condition computed from `xT_plus`. `P`\nis the auxiliary diffusion law, `obs` is the observation made at time\n`tt[end]` and `choices` contains information about eltype and the algorithm\nfor solving ODEs. H,F,c are saved on a grid of time-points `tt`.\n\n    HFcSolver(\n        ::Val{:outofplace},\n        tt,\n        xT_plus,\n        P,\n        obs,\n        choices\n    )\nConstructor for an ODE solver with out-of-place operations using\nStaticArrays. Initialises the object and solves a (H,F,c)-system of ODEs\nonce, backward in time on the interval `(tt[1], tt[end])`, with a terminal\ncondition computed from `xT_plus`. `P` is the auxiliary diffusion law, `obs`\nis the observation made at time `tt[end]` and `choices` contains information\nabout eltype and the algorithm for solving ODEs. H,F,c are saved on a grid\nof time-points `tt`.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#GuidedProposals.IntegrationRule","page":"Index","title":"GuidedProposals.IntegrationRule","text":"IntegrationRule\n\nSupertype of all integration rules. In this package we currently approximate the integrals by step functions with evaluations at the left side of the intervals.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#GuidedProposals.LeftRule","page":"Index","title":"GuidedProposals.LeftRule","text":"LeftRule <: IntegrationRule\n\nIntegration rule flag, indicating to approximate functions with step functions with height equal to function evaluation at the left side of the intevals.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#Base.Libc.time-Tuple{GuidProp,Any}","page":"Index","title":"Base.Libc.time","text":"Base.time(P::GuidProp, i)\n\nReturn time-point tt[i] corresponding to a saved state of ODEs (with tt[1] indicating time 0+ and tt[end] indicating time T).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.rand","page":"Index","title":"Base.rand","text":"Base.rand(\n    [rng::Random.AbstractRNG], P::GuidProp, y1=zero(P); f=DD.__DEFAULT_F\n)\n\nSample a trajectory of a guided proposal P started from y1. Initialize containers in the background and compute the functional f at the time of sampling.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Base.rand","page":"Index","title":"Base.rand","text":"Base.rand(\n    [rng::Random.AbstractRNG],\n    PP::AbstractArray{<:GuidProp}, y1=zero(PP[1]); f=DD.__DEFAULT_F\n)\n\nSample a trajectory started from y1, defined for multiple guided proposals PP that correspond to consecutive intervals. Initialize containers in the background and compute the functionals f (one for each interval) at the time of sampling.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#DiffusionDefinition.dimension-Tuple{GuidProp}","page":"Index","title":"DiffusionDefinition.dimension","text":"DD.dimension(P::GuidProp)\n\nDimension of the stochastic process and the driving Brownian motion (by default the same as that of the target process)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionDefinition.same_entries-Tuple{AbstractArray{#s24,N} where N where #s24<:GuidProp,AbstractArray{#s22,N} where N where #s22<:GuidProp,Any}","page":"Index","title":"DiffusionDefinition.same_entries","text":"DD.same_entries(\n    PP::AbstractArray{<:GuidProp},\n    PP°::AbstractArray{<:GuidProp},\n    entries\n)\n\nGo through the collections of guided proposals PP and PP° and compare if they share the same values of fields listed in entries.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionDefinition.set_parameters!","page":"Index","title":"DiffusionDefinition.set_parameters!","text":"DD.set_parameters!(\n    PP::AbstractArray{<:GuidProp},\n    PP°::AbstractArray{<:GuidProp},\n    θ°,\n    var_p_names,\n    var_p_aux_names,\n    θ_local_names,\n    θ_local_aux_names,\n    θ_local_obs_ind,\n    critical_change = is_critical_update(\n        PP, θ_local_aux_names, θ_local_obs_ind\n    ),\n)\n\nSet parameters of Guided proposals PP° in an MCMC setting.\n\n...\n\nArguments\n\nPP: containers indicating how PP° should look like before θ° update\nθ°: a vector with new parameters to be potentially set inside PP°\nvar_p_names: list of all variable parameter names in PP\nvar_p_aux_names: list of all variable parameter names of auxiliary laws in\n\nPP\n\nθ_local_names: list of pairs with relevant θ° entries for the target law\n\nin a format (idx-of-param-in-θ°::Int64, param-name-in-law::Symbol)\n\nθ_local_aux_names: list of pairs with relevant θ° entries for the aux law\n\nin a format (idx-of-param-in-θ°::Int64, param-name-in-law::Symbol)\n\nθ_local_obs_ind: list of pairs with relevant θ° entries for the\n\nobservations in a format (idx-of-param-in-θ°::Int64, idx-in-obs::Int64)\n\ncritical_change: boolean for whether θ° update alters any critical\n\nparameters prompting for recomputation of the guiding term ...\n\n\n\n\n\n","category":"function"},{"location":"module_index/#DiffusionDefinition.set_parameters!-Tuple{AbstractArray{#s24,N} where N where #s24<:GuidProp,Any,Any,Any,Any}","page":"Index","title":"DiffusionDefinition.set_parameters!","text":"DD.set_parameters!(\n    PP::AbstractArray{<:GuidProp},\n    θ°,\n    θ_local_names,\n    θ_local_aux_names,\n    θ_local_obs_ind\n)\n\nGo throught the collection of GuidProps in PP and set the new parameters θ° in relevant fields. θ_local_names lists which fields in the target law need changing. θ_local_aux_names lists the same for the auxiliary laws and θ_local_obs_ind for the observations.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionDefinition.set_parameters!-Tuple{AbstractArray{#s24,N} where N where #s24<:GuidProp,Dict}","page":"Index","title":"DiffusionDefinition.set_parameters!","text":"DD.set_parameters!(PP::AbstractArray{<:GuidProp}, θ°::Dict)\n\nConvenience parameter setter\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionDefinition.set_parameters!-Tuple{GuidProp,Any,Any,Any,Any}","page":"Index","title":"DiffusionDefinition.set_parameters!","text":"DD.set_parameters!(\n    P::GuidProp,\n    θ°,\n    θ_local_names,\n    θ_local_aux_names,\n    θ_local_obs_ind\n)\n\nSet the new parameters θ° in P. θ_local_names lists which fields in the target law need changing. θ_local_aux_names lists the same for the auxiliary law and θ_local_obs_ind for the observation.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionDefinition.set_parameters!-Tuple{GuidProp,Dict}","page":"Index","title":"DiffusionDefinition.set_parameters!","text":"DD.set_parameters!(P::GuidProp, θ°::Dict)\n\nConvenience parameter setter\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.HFc0-Tuple{GuidProp}","page":"Index","title":"GuidedProposals.HFc0","text":"HFc0(P::GuidProp)\n\nReturn the container with data that can be used to reconstruct H,F,c evaluated at time 0+ for the guided proposal P.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.HFc0-Tuple{GuidedProposals.HFcSolver}","page":"Index","title":"GuidedProposals.HFc0","text":"HFc0(s::HFcSolver)\n\nReturn the data containing H,F,c terms for the time 0+\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.build_artif_obs-Tuple{Any,Any,Any}","page":"Index","title":"GuidedProposals.build_artif_obs","text":"build_artif_obs(obs, proto_obs, ϵ)\n\nBuild an artifical observation for the blocking scheme.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.equalize_law_params!-Tuple{AbstractArray{#s22,N} where N where #s22<:GuidProp,AbstractArray{#s21,N} where N where #s21<:GuidProp,Any,Any}","page":"Index","title":"GuidedProposals.equalize_law_params!","text":"equalize_law_params!(\n    PP::AbstractArray{<:GuidProp},\n    PP°::AbstractArray{<:GuidProp},\n    var_p_names,\n    var_p_aux_names,\n)\n\nGo through two collections of GuidProp and compare their variable parameters. If any of the parameters in PP° ends up being different than in PP then equalize them and if any of them belongs to the auxiliary law then return a critical_change flag.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.equalize_obs_params!-Tuple{AbstractArray{#s22,N} where N where #s22<:GuidProp,AbstractArray{#s21,N} where N where #s21<:GuidProp}","page":"Index","title":"GuidedProposals.equalize_obs_params!","text":"equalize_obs_params!(\n    PP::AbstractArray{<:GuidProp},\n    PP°::AbstractArray{<:GuidProp}\n)\n\nGo through a collection of GuidProp in PP° and make sure that all observation parameters are the same. If not, equalize them and return a critical_change flag indicating that GuidProp laws need to be recomputed.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.extract_parameters_to_pass-Tuple{Any,Any}","page":"Index","title":"GuidedProposals.extract_parameters_to_pass","text":"extract_parameters_to_pass(P_target, P_aux_type)\n\nA helper function for building an instance of P_aux_type using an initialized P_target. Retreive parameter values from P_target for all parameter names that appear also in P_aux_type.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.fetch_eltype-Tuple{Any,Any}","page":"Index","title":"GuidedProposals.fetch_eltype","text":"fetch_eltype(choices, P)\n\nDetermine the type of the elements that is supposed to be used by the internal containers of this package. If choice.gradients flag is turned on, then use the same type as the eltypes of the parameters in the auxiliary law. Otherwise, use the type specified in choice. If neither the choice.gradients flag is on, nor a default is provided, use Float64.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.fetch_xT_plus","page":"Index","title":"GuidedProposals.fetch_xT_plus","text":"fetch_xT_plus(::Val{:inplace}, next_guided_prop, el, dim_of_proc)\n\nIf this is not the last inter-observation interval, fetch the data containing H,F,c computed for the left time-limit of the subsequent interval. Otherwise, instantiate a zero-term.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#GuidedProposals.get_or_default-Tuple{Any,Symbol,Any}","page":"Index","title":"GuidedProposals.get_or_default","text":"get_or_default(container, elem::Symbol, default)\n\nReturn container.elem if it exists, otherwise return default\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.init_solver-Tuple{Val{:hfc},Any,Any,Any,Any,Val,Any,Any}","page":"Index","title":"GuidedProposals.init_solver","text":"init_solver(\n    ::Val{:hfc},\n    ::Any,\n    tt,\n    P_aux,\n    obs,\n    mode::Val,\n    choices,\n    next_guided_prop\n)\n\nInitialise ODE solver for H,F,c, preallocate space and solve it once. tt is the time-grid on which ∇logρ is to be saved. P_aux is the auxiliary law, obs is the terminal observation, mode is for differentiating between in-place, out-of-place and gpu constructors for the guiding term solver, choices contains additional information that is passed on (and which is about eltype and a chosen algorithm for the ODE solvers) and finally, next_guided_prop is the guided proposal used on the subsequent inter-observation interval.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.is_critical_update-Tuple{AbstractArray{#s24,N} where N where #s24<:GuidProp,Any,Any}","page":"Index","title":"GuidedProposals.is_critical_update","text":"is_critical_update(\n    PP::AbstractArray{<:GuidProp},\n    θ_local_aux_names,\n    θ_local_obs_ind\n)\n\nCheck if the update of parameters that updates the fields of the auxiliary law listed in θ_local_aux_names and the observations listed in θ_local_obs_ind is critical i.e. whether it prompts for recomputation of the guiding term.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.mode-Tuple{GuidProp}","page":"Index","title":"GuidedProposals.mode","text":"mode(P::GuidProp)\n\nReturn the mode of solving ODE systems (:inplace, :outofplace or :gpu) [TODO not used much, for multiple dispatch needs to return Val{mode}() instead, change  or remove].\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.outer-Tuple{Any}","page":"Index","title":"GuidedProposals.outer","text":"outer(x)\n\nCompute an outer product\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.prepare_static_saving_types-Union{Tuple{D}, Tuple{Val{:hfc},Val{D},Any}} where D","page":"Index","title":"GuidedProposals.prepare_static_saving_types","text":"prepare_static_saving_types(::Val{:hfc}, ::Val{D}, el) where D\n\nDefine data-types for H,F,c computed by out-of-place solver that are to be saved internally.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.reformat-Tuple{NamedTuple,Bool,Any}","page":"Index","title":"GuidedProposals.reformat","text":"reformat(solver_choice::NamedTuple, last_interval::Bool, P_aux)\n\nRe-format the solver_choice by splitting it into two NamedTuples and populating any missing entries with defaults. P_aux is the law of the auxiliary diffusion that is needed in case a flag for computing gradients is turned on.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.size_of_HFc_buffer-Tuple{Any}","page":"Index","title":"GuidedProposals.size_of_HFc_buffer","text":"size_of_HFc_solution(d)\n\nLength of a vector containing temporary data needed for in-place solver of H,F,c, when the underlying process has dimension d.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.size_of_HFc_solution-Tuple{Any}","page":"Index","title":"GuidedProposals.size_of_HFc_solution","text":"size_of_HFc_solution(d)\n\nCompute the size of a vector containing H,F,c elements\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.solve_and_ll!-Tuple{Any,Any,GuidProp,Any}","page":"Index","title":"GuidedProposals.solve_and_ll!","text":"solve_and_ll!(X, W, P, y1)\n\nCompute the trajectory under the law P for a given Wiener noise W and a starting point y1. Store the trajectory in XX. Compute the log-likelihood (path contribution) along the way. Return success_flag and log-likelihood. success_flag is set to false only if sampling was prematurely halted due to XX violating assumptions about state space.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.static_accessor_HFc-Union{Tuple{T}, Tuple{K}, Tuple{K,Val{T}}} where T where K<:Union{StaticArrays.MArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S},T,1,S} where T where S}","page":"Index","title":"GuidedProposals.static_accessor_HFc","text":"static_accessor_HFc(u::SVector, ::Val{T}) where T\n\nAccess data stored in the container u so that it matches the shapes of H,F,c and points to the correct points in u. T is the dimension of the stochastic process.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.update_HFc!-Tuple{Any,Any,Any}","page":"Index","title":"GuidedProposals.update_HFc!","text":"update_HFc!(u_T, u_Tplus, obs, access)\n\nUpdate equations for H,F,c at the times of observations. Save the data into u_T.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.update_HFc-Tuple{Any,Any,Any}","page":"Index","title":"GuidedProposals.update_HFc","text":"update_HFc(u_Tplus, obs, access)\n\nUpdate equations for H,F,c at the times of observations.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG],\n    P::GuidProp,\n    X, W, y1=zero(P);\n    f=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X and W to save the results. Compute the functional f at the time of sampling.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG]\n    P::GuidProp,\n    X°, W°, W, ρ, v::Val{:ll}, y1=zero(P);\n    Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X° and W° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter ρ and a previously sampled Wiener noise W. Compute log-likelihood (only path contribution) along the way.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG],\n    P::GuidProp,\n    X°, W°, W, ρ, y1=zero(P);\n    f=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X° and W° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter ρ and a previously sampled Wiener noise W. Compute the functional f at the time of sampling.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG]\n    P::GuidProp,\n    X, W, v::Val{:ll}, y1=zero(P);\n    Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X and W to save the results. Compute log-likelihood (only path contribution) along the way.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX, WW, v::Val{:ll}, y1=zero(PP[1]);\n    Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX° and WW° to save the results. Compute log-likelihood (path contribution AND end-points contribution) along the way.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX°, WW°, WW, ρρ, v::Val{:ll}, y1=zero(PP[1]);\n    Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX° and WW° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameters ρ (one for the entire interval) and a previously sampled Wiener noise WW. Compute log-likelihood (path contribution AND end-points contribution) along the way.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX, WW, y1=zero(PP[1]);\n    f=DD.__DEFAULT_F, f_out=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX and WW to save the results. Compute the functionals f (one for each interval) at the time of sampling and store the results in f_out.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX°, WW°, WW, ρρ, y1=zero(PP[1]);\n    f=DD.__DEFAULT_F, f_out=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX° and WW° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter ρ (one for the entire interval) and a previously sampled Wiener noise WW. Compute the functionals f (one for each interval) at the time of sampling and store the results in f_out.\n\n\n\n\n\n","category":"function"},{"location":"get_started/overview/#get_started-1","page":"Get started","title":"Installation","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"The package is not registered yet. To install it write:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"] add https://github.com/JuliaDiffusionBayes/GuidedProposals.jl","category":"page"},{"location":"get_started/overview/#Define-the-law-of-a-guided-proposal-1","page":"Get started","title":"Define the law of a guided proposal","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"The main object defined by this package is GuidProp. It allows for a definition of a guided proposal [arXiv] with some target and auxiliary diffusion laws. To define it, use DiffusionDefinition.jl to define the unconditioned laws, ObservationSchemes.jl to define the observation, and then, construct a GuidProp","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"using GuidedProposals, DiffusionDefinition, ObservationSchemes\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\n\nusing StaticArrays, LinearAlgebra\n\n@load_diffusion LotkaVolterra\n@load_diffusion LotkaVolterraAux\n\n# define target law\nθ = [2.0/3.0, 4.0/3.0, 1.0, 1.0, 0.1, 0.1]\nP_target = LotkaVolterra(θ...)\n\n# define the observation and a time-grid\nT, vT = 3.0, @SVector [0.5, 0.8]\ntt, y1 = 0.0:0.001:T, @SVector [2.0, 0.25]\nobs = LinearGsnObs(T, vT; Σ=1e-4*SDiagonal{2,Float64}(I))\n\n# define a guided proposal\nP = GuidProp(tt, P_target, LotkaVolterraAux, obs)","category":"page"},{"location":"get_started/overview/#Define-the-laws-of-multiple-guided-proposals-1","page":"Get started","title":"Define the laws of multiple guided proposals","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"If there are more than one (non-full) observations, then you should construct one GuidProp for each inter-observation interval. This is done automatically with build_guid_prop:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"# multiple obsevations\nobservs = load_data(\n    ObsScheme(\n        LinearGsnObs(\n            0.0, zero(SVector{2,Float64});\n            Σ = 1e-4*SDiagonal(1.0, 1.0)\n        )\n    ),\n    [1.0, 2.0, 3.0],\n    [[2.2, 0.7], [0.9, 1.0], [0.5, 0.8]]\n)\n\n# packaged in a format of a `recording` from ObservationSchemes.jl\nrecording = (\n    P = P_target,\n    obs = observs,\n    t0 = 0.0,\n    x0_prior = undef\n)\ntts = OBS.setup_time_grids(recording, 0.001)\n\n# create a guided proposal for multiple observations\nPP = build_guid_prop(LotkaVolterraAux, recording, tts)","category":"page"},{"location":"get_started/overview/#Sample-guided-proposals-1","page":"Get started","title":"Sample guided proposals","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"Sampling is done with a function rand:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"X, W, Wnr = rand(P, y1)","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"that initializes all containers, or with rand! if you initialize the containers yourself:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"X, W = trajectory(P)\nrand!(P, X, W, y1; Wnr=Wnr)","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"The functions above work for multiple GuidProp as well (that correspond to multiple observations):","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"XX, WW, Wnr = rand(PP, y1)\n# OR\nXX, WW = trajectory(PP)\nrand!(PP, XX, WW, y1)","category":"page"},{"location":"get_started/overview/#Compute-log-likelihoods-1","page":"Get started","title":"Compute log-likelihoods","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"Computation of the log-likelihood may happen after the path has been sampled:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"ll_path_contrib = loglikhd(P, X)\nll_obs_contrib = loglikhd_obs(P, y1)\nll = ll_path_contrib + ll_obs_contrib\n# OR when passing multiple observations:\nll = loglikhd(PP, XX)","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"or at the time of sampling","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"_, ll_path_contrib = rand!(P, X, W, Val(:ll), y1; Wnr=Wnr)\nll_obs_contrib = loglikhd_obs(P, y1)\nll = ll_path_contrib + ll_obs_contrib\n# OR when passing multiple observations:\n_, ll = rand!(PP, XX, WW, Val(:ll), y1; Wnr=Wnr)","category":"page"},{"location":"get_started/overview/#Compute-path-functionals-1","page":"Get started","title":"Compute path functionals","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"To evaluate functionals while sampling simply pass the method as a named argument f=....","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"X, W, Wnr, f_out = rand(P, y1; f=foo)","category":"page"},{"location":"get_started/overview/#Compute-gradients-of-log-likelihood-or-path-functionals-1","page":"Get started","title":"Compute gradients of log-likelihood or path functionals","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"warning: TODO\nto be written-up","category":"page"},{"location":"manual/multiple_obs/#multi_obs_gp-1","page":"Multiple observations","title":"Guided proposals with multiple observations","text":"","category":"section"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"In practice, it is often of interest to sample from some target diffusion law","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"dd X_t = b(tX_t)dd t + sigma(tX_t) dd W_tquad tin0Tquad X_0sim p_0","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"conditionally on multiple, partial observations of X:","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"V_t_i=left L_iX_t_i+eta_ii=1dotsN rightquad L_iinRR^m_itimes dquad eta_isim N(mu_iSigma_i)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"not only a single one. This can be done by stacking together GuidProp, each defined on its own interval t_i-1t_i and for its own terminal observation V_t_i. The initialization may be done implicitly if you call","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"GuidedProposals.build_guid_prop","category":"page"},{"location":"manual/multiple_obs/#GuidedProposals.build_guid_prop","page":"Multiple observations","title":"GuidedProposals.build_guid_prop","text":"build_guid_prop(\n    ::Type{AuxLaw}, recording::NamedTuple, tts::Vector, args...; kwargs...\n) where {AuxLaw <: DD.DiffusionProcess}\n\nInitialize multiple instances of GuidProp corresponding to guided proposals for observations stored in recording. The time grids for each inter-observation interval is given in tts and AuxLaw is the auxiliary law for creating guided proposals. args... are passed to each constructor of GuidProp.\n\n\n\n\n\nbuild_guid_prop(\n    aux_laws::AbstractArray, recording::NamedTuple, tts::Vector, args, kwargs\n)\n\nSame as a version with ::Type{AuxLaw}, but aux_laws is a list of auxiliary laws that correspond to each inter-observation interval.\n\n\n\n\n\n","category":"function"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"For instance:","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"observs = load_data(\n    ObsScheme(\n        LinearGsnObs(\n            0.0, zero(SVector{2,Float64});\n            Σ = 1e-4*SDiagonal(1.0, 1.0)\n        )\n    ),\n    [1.0, 2.0, 3.0],\n    [[2.2, 0.7], [0.9, 1.0], [0.5, 0.8]]\n)\n\nrecording = (\n    P = P_target,\n    obs = observs,\n    t0 = 0.0,\n    x0_prior = undef # normally, we would provide a prior, however for the steps\n    # below it is not needed\n)\ntts = OBS.setup_time_grids(recording, 0.001)\n\nPP = build_guid_prop(LotkaVolterraAux, recording, tts)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"where we have packaged the observations in a format of a recording from ObservationSchemes.jl","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"note: Note\nIt is possible to perform the steps hidden behind a call to build_guid_prop explicitly. To properly initialize the guiding term we must defined the sequence of GuidProp starting from the last interval t_N-1t_N and proceed moving backwards: t_N-2t_N-1dots0t_1, each time passing a GuidProp from the subsequent interval t_it_i+1 to the GuidProp that is being defined on t_i-1t_i. For the observations above this becomes:P_intv3 = GuidProp(tts[3], P_target, LotkaVolterraAux, observs[3])\nP_intv2 = GuidProp(tts[2], P_target, LotkaVolterraAux, observs[2]; next_guid_prop=P_intv3)\nP_intv1 = GuidProp(tts[1], P_target, LotkaVolterraAux, observs[1]; next_guid_prop=P_intv2)That's it, now a vectorP = [P_intv1, P_intv2, P_intv3]is equivalent to PP defined before. Needless to say, calling build_guid_prop instead is recommended.","category":"page"},{"location":"manual/multiple_obs/#Sampling-a-single-trajectory-1","page":"Multiple observations","title":"Sampling a single trajectory","text":"","category":"section"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"Sampling is done analogously to how it was done for a case of a single observation. Simply call rand if you wish to have containers initialized in the background:","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"# sample\nXX, WW, Wnr = rand(PP, y1)\n\n# build a plot\np = plot()\nfor i in 1:3\n    plot!(p, XX[i], Val(:x_vs_y); color=\"steelblue\",label=\"\")\nend\nscatter!(p, [y1[1]],[y1[2]], markersize=8, label=\"starting point\")\nfor i in 1:3\n    o = OBS.obs(recording.obs[i])\n    scatter!(p, [o[1]], [o[2]]; label=\"observation $i\", markersize=8, marker=:diamond, markercolor=\"orange\")\nend\ndisplay(p)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"(Image: guid_prop_multi)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"Alternatively, initialize containers yourself and then call rand!:","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"XX, WW = trajectory(PP)\nrand!(PP, XX, WW, y1)","category":"page"},{"location":"manual/multiple_obs/#Sampling-multiple-trajectories-1","page":"Multiple observations","title":"Sampling multiple trajectories","text":"","category":"section"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"As it was the case with single observation, sampling multiple trajectories often involves computation of the log-likelihood. Analogously to how it was explained in the previous section, there are three ways of computing log-likelihood and the preferred way is to use the optimized rand! samplers that compute log-likelihoods as the path is being sampled.","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"success, ll = rand!(PP, XX, WW, Val(:ll), y1)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"Smoothing is now as simple as it was for a single observation. In fact, thanks to the magic of Julia's multiple dispatch we may call the exact same function simple_smoothing that was defined in the previous section and it will work for multiple observations as well!","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"paths = simple_smoothing(P, y1)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"(Image: lotka_volterra_simple_smoothing_multi)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"note: Note\nA log-likelihood computed by rand! for a list of trajectories is slightly different than the log-likelihood computed for a single segment. An additional term due to transition densities is added. See the section on log-likelihoods for more details.","category":"page"},{"location":"manual/multiple_obs/#Preconditioned-Crank-Nicolson-scheme-1","page":"Multiple observations","title":"Preconditioned Crank-Nicolson scheme","text":"","category":"section"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"Perturbing Gaussian noise instead of sampling it anew works in exactly the same way as in the previous section.","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"XX°, WW° = trajectory(PP)\nρ = 0.5 # one memory param for the entire interval\nrand!(PP, XX°, WW°, WW, ρ, y1)","category":"page"},{"location":"manual/reparameterizations/#Reparameterizations-of-GuidProp-1","page":"Reparameterizations","title":"Reparameterizations of GuidProp","text":"","category":"section"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"","category":"page"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"In an MCMC setting we may wish to change the values of some parameters of GuidProp. GuidProp is defined as an immutable struct; however, the fields containing parameter values are mutable, and thus, changing parameters may be done in-place. Changing them directly by accessing relevant places that store parameter values is not advisable, instead, it is recommended to use one of the relevant convenience functions:","category":"page"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"GuidedProposals.set_parameters!\nGuidedProposals.equalize_obs_params!\nGuidedProposals.equalize_law_params!\nGuidedProposals.same_entries\nGuidedProposals.is_critical_update","category":"page"},{"location":"manual/reparameterizations/#DiffusionDefinition.set_parameters!","page":"Reparameterizations","title":"DiffusionDefinition.set_parameters!","text":"DD.set_parameters!(\n    PP::AbstractArray{<:GuidProp},\n    PP°::AbstractArray{<:GuidProp},\n    θ°,\n    var_p_names,\n    var_p_aux_names,\n    θ_local_names,\n    θ_local_aux_names,\n    θ_local_obs_ind,\n    critical_change = is_critical_update(\n        PP, θ_local_aux_names, θ_local_obs_ind\n    ),\n)\n\nSet parameters of Guided proposals PP° in an MCMC setting.\n\n...\n\nArguments\n\nPP: containers indicating how PP° should look like before θ° update\nθ°: a vector with new parameters to be potentially set inside PP°\nvar_p_names: list of all variable parameter names in PP\nvar_p_aux_names: list of all variable parameter names of auxiliary laws in\n\nPP\n\nθ_local_names: list of pairs with relevant θ° entries for the target law\n\nin a format (idx-of-param-in-θ°::Int64, param-name-in-law::Symbol)\n\nθ_local_aux_names: list of pairs with relevant θ° entries for the aux law\n\nin a format (idx-of-param-in-θ°::Int64, param-name-in-law::Symbol)\n\nθ_local_obs_ind: list of pairs with relevant θ° entries for the\n\nobservations in a format (idx-of-param-in-θ°::Int64, idx-in-obs::Int64)\n\ncritical_change: boolean for whether θ° update alters any critical\n\nparameters prompting for recomputation of the guiding term ...\n\n\n\n\n\nDD.set_parameters!(\n    PP::AbstractArray{<:GuidProp},\n    θ°,\n    θ_local_names,\n    θ_local_aux_names,\n    θ_local_obs_ind\n)\n\nGo throught the collection of GuidProps in PP and set the new parameters θ° in relevant fields. θ_local_names lists which fields in the target law need changing. θ_local_aux_names lists the same for the auxiliary laws and θ_local_obs_ind for the observations.\n\n\n\n\n\nDD.set_parameters!(\n    P::GuidProp,\n    θ°,\n    θ_local_names,\n    θ_local_aux_names,\n    θ_local_obs_ind\n)\n\nSet the new parameters θ° in P. θ_local_names lists which fields in the target law need changing. θ_local_aux_names lists the same for the auxiliary law and θ_local_obs_ind for the observation.\n\n\n\n\n\nDD.set_parameters!(P::GuidProp, θ°::Dict)\n\nConvenience parameter setter\n\n\n\n\n\nDD.set_parameters!(PP::AbstractArray{<:GuidProp}, θ°::Dict)\n\nConvenience parameter setter\n\n\n\n\n\n","category":"function"},{"location":"manual/reparameterizations/#GuidedProposals.equalize_obs_params!","page":"Reparameterizations","title":"GuidedProposals.equalize_obs_params!","text":"equalize_obs_params!(\n    PP::AbstractArray{<:GuidProp},\n    PP°::AbstractArray{<:GuidProp}\n)\n\nGo through a collection of GuidProp in PP° and make sure that all observation parameters are the same. If not, equalize them and return a critical_change flag indicating that GuidProp laws need to be recomputed.\n\n\n\n\n\n","category":"function"},{"location":"manual/reparameterizations/#GuidedProposals.equalize_law_params!","page":"Reparameterizations","title":"GuidedProposals.equalize_law_params!","text":"equalize_law_params!(\n    PP::AbstractArray{<:GuidProp},\n    PP°::AbstractArray{<:GuidProp},\n    var_p_names,\n    var_p_aux_names,\n)\n\nGo through two collections of GuidProp and compare their variable parameters. If any of the parameters in PP° ends up being different than in PP then equalize them and if any of them belongs to the auxiliary law then return a critical_change flag.\n\n\n\n\n\n","category":"function"},{"location":"manual/reparameterizations/#DiffusionDefinition.same_entries","page":"Reparameterizations","title":"DiffusionDefinition.same_entries","text":"DD.same_entries(\n    PP::AbstractArray{<:GuidProp},\n    PP°::AbstractArray{<:GuidProp},\n    entries\n)\n\nGo through the collections of guided proposals PP and PP° and compare if they share the same values of fields listed in entries.\n\n\n\n\n\n","category":"function"},{"location":"manual/reparameterizations/#GuidedProposals.is_critical_update","page":"Reparameterizations","title":"GuidedProposals.is_critical_update","text":"is_critical_update(\n    PP::AbstractArray{<:GuidProp},\n    θ_local_aux_names,\n    θ_local_obs_ind\n)\n\nCheck if the update of parameters that updates the fields of the auxiliary law listed in θ_local_aux_names and the observations listed in θ_local_obs_ind is critical i.e. whether it prompts for recomputation of the guiding term.\n\n\n\n\n\n","category":"function"},{"location":"manual/reparameterizations/#recompute_guiding_term-1","page":"Reparameterizations","title":"Re-computing the guiding term","text":"","category":"section"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"","category":"page"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"Sometimes changing parameter values is all that needs to be done; however, it is not always the case. Often changing parameter values implies that the terms used for computation of the guiding term also need to be updated. This needs to be done whenever any parameter of the auxiliary law or any parameter of an observation has changed.","category":"page"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"To actually re-compute the guiding terms and finalize the reparameterization you need to call","category":"page"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"GuidedProposals.recompute_guiding_term!","category":"page"},{"location":"manual/reparameterizations/#GuidedProposals.recompute_guiding_term!","page":"Reparameterizations","title":"GuidedProposals.recompute_guiding_term!","text":"recompute_guiding_term!(P::GuidProp, next_guided_prop=nothing)\n\nRecompute the guiding term (most often used after update of parameters or change of an observation). next_guided_prop is the guided proposal law from the subsequent interval\n\n\n\n\n\nrecompute_guiding_term!(PP::Vector{<:GuidProp})\n\nRecompute the guiding term for the entire trajectory with all observations (most often used after update of parameters or change of an observation).\n\n\n\n\n\n","category":"function"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"All changes above are done in-place.","category":"page"},{"location":"manual/log_likelihood/#log_likelihood_computations-1","page":"Log-likelihoods","title":"Computations of log-likelihoods","text":"","category":"section"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"The full likelihood function for a sampled path X given by:","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"frac\n    colorforestgreen\n        tilderho(0X_0)\n    \n\n    colormaroon\n        rho(0X_0)\n    \nexpleft\n    colorroyalblue\n        int_0^T G(t X_t) dd t\n    \nright","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"where","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"G(tx)=left\n    (b-tildeb)^Ttilder\n    + 05 trleft\n        (a-tildea)(tildertilder^T-H)\n    right\nright(tx)","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"and tilder(tx)=nablalogtilderho(tx). The terms colorroyalblueint_0^T G(t X_t) dd t, and logleft(colorforestgreentilderho(0X_0)right) may be computed with functions:","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"GuidedProposals.loglikhd","category":"page"},{"location":"manual/log_likelihood/#GuidedProposals.loglikhd","page":"Log-likelihoods","title":"GuidedProposals.loglikhd","text":"loglikhd([::IntegrationRule=::LeftRule], P::GuidProp, X::Trajectory; skip=0)\n\nCompute path contribution to the log-likelihood function, i.e.:\n\nint_0^T G(t X_t) dt\n\nwhere\n\nG(tx)=left\n    (b-tildeb)^Ttilder\n    + 05 trleft\n        (a-tildea)(tildertilder^T-H)\n    right\nright(tx)\n\nand tilder(tx)=nablalogtilderho(tx).\n\nloglikhd(\n    [::IntegrationRule=::LeftRule],\n    PP::AbstractArray{<:GuidProp}, XX::AbstractArray{<:Trajectory};\n    skip=0\n)\n\nCompute path contribution to the log-likelihood function for a sequence of segments.\n\n\n\n\n\n","category":"function"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"and","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"GuidedProposals.loglikhd_obs","category":"page"},{"location":"manual/log_likelihood/#GuidedProposals.loglikhd_obs","page":"Log-likelihoods","title":"GuidedProposals.loglikhd_obs","text":"loglikhd_obs(P::GuidProp, x0)\n\nCompute the contribution of end-points to the log-likelihood function, i.e.: logrho(tx).\n\n\n\n\n\n","category":"function"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"respectively. In general, deriving the term colormaroonrho(0X_0) explicitly is impossible. Thankfully though, in an MCMC or an importance sampling setting this term always cancels out and so never needs to be computed.","category":"page"},{"location":"manual/log_likelihood/#Log-likelihood-computation-whilst-sampling-1","page":"Log-likelihoods","title":"Log-likelihood computation whilst sampling","text":"","category":"section"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"Function rand!—when called with a parameter Val(:ll)—computes the \"log-likelihood\" at the time of sampling. Internally the following function is called after the Wiener process is sampled.","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"GuidedProposals.solve_and_ll!","category":"page"},{"location":"manual/log_likelihood/#GuidedProposals.solve_and_ll!","page":"Log-likelihoods","title":"GuidedProposals.solve_and_ll!","text":"solve_and_ll!(X, W, P, y1)\n\nCompute the trajectory under the law P for a given Wiener noise W and a starting point y1. Store the trajectory in XX. Compute the log-likelihood (path contribution) along the way. Return success_flag and log-likelihood. success_flag is set to false only if sampling was prematurely halted due to XX violating assumptions about state space.\n\n\n\n\n\n","category":"function"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"solve_and_ll! computes only colorroyalblueint_0^T G(t X_t) dd t.","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"When rand! is called on a single GuidProp (i.e. a single interval) then only this path contribution is returned.\nHowever, if rand! is called on a list of GuidProp, then apart from summing over the results from solve_and_ll! an additional end-point contribution is added, i.e.","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"colorroyalblueint_0^T G(t X_t) dd t+logleft(colorforestgreentilderho(0X_0)right)","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"is returned.","category":"page"},{"location":"how_to_guides/smoothing/#how_to_smoothing-1","page":"...smooth trajectories","title":"How to do smoothing of diffusion trajectories?","text":"","category":"section"},{"location":"how_to_guides/smoothing/#","page":"...smooth trajectories","title":"...smooth trajectories","text":"","category":"page"},{"location":"how_to_guides/smoothing/#","page":"...smooth trajectories","title":"...smooth trajectories","text":"Smoothing is a process of reconstructing the unobserved parts of the path, based on the recorded observations.","category":"page"},{"location":"how_to_guides/smoothing/#","page":"...smooth trajectories","title":"...smooth trajectories","text":"# Perform smoothing for the data in the `recording`, using Guided Proposals with\n# the auxiliary law `AuxLaw`.\nfunction simple_smoothing(AuxLaw, recording, dt; ρ=0.5, num_steps=10^4)\n    # -------------------------------------------------------------------------#\n    #                          Initializations                                 #\n    # -------------------------------------------------------------------------#\n    # time-grids for the forward-simulation of trajectories                    #\n    tts = OBS.setup_time_grids(recording, dt)                                  #\n    # laws of guided proposals                                                 #\n    PP = build_guid_prop(AuxLaw, recording, tts)                               #\n                                                                               #\n    # starting point                                                           #\n    # NOTE `rand` for `KnownStartingPt` simply returns the starting position   #\n    y1 = rand(recording.x0_prior)                                              #\n    # initialize the `accepted` trajectory                                     #\n    XX, WW, Wnr = rand(PP, y1)                                                 #\n    # initialize the containers for the `proposal` trajectory                  #\n    XX°, WW° = trajectory(PP)                                                  #\n                                                                               #\n    ll = loglikhd(PP, XX)                                                      #\n    paths = []                                                                 #\n    num_accpt = 0                                                              #\n    # -------------------------------------------------------------------------#\n\n    # MCMC\n    for i in 1:num_steps\n        # impute a path\n        _, ll° = rand!(PP, XX°, WW°, WW, ρ, Val(:ll), y1; Wnr=Wnr)\n\n        # Metropolis–Hastings accept/reject step\n        if rand() < exp(ll°-ll)\n            XX, WW, XX°, WW° = XX°, WW°, XX, WW\n            ll = ll°\n            num_accpt += 1\n        end\n\n        # progress message\n        if i % 100 == 0\n            println(\"$i. ll=$ll, acceptance rate: $(num_accpt/100)\")\n            num_accpt = 0\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(XX)])\n    end\n    paths\nend","category":"page"},{"location":"how_to_guides/smoothing/#Example-1","page":"...smooth trajectories","title":"Example","text":"","category":"section"},{"location":"how_to_guides/smoothing/#","page":"...smooth trajectories","title":"...smooth trajectories","text":"For instance, for a partially observed FitzHugh–Nagumo model","category":"page"},{"location":"how_to_guides/smoothing/#","page":"...smooth trajectories","title":"...smooth trajectories","text":"recording = ...\npaths = simple_smoothing(\n    FitzHughNagumoAux, recording, 0.001; ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"how_to_guides/smoothing/#","page":"...smooth trajectories","title":"...smooth trajectories","text":"(Image: paths)","category":"page"},{"location":"how_to_guides/smoothing/#","page":"...smooth trajectories","title":"...smooth trajectories","text":"It takes about 6sec on my laptop.","category":"page"},{"location":"tutorials/smoothing/#tutorial_smoothing-1","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"","category":"section"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"In this tutorial we will smooth trajectories of a diffusion process, based on discrete-time observations of its sampled trajectory. We will apply the algorithm to an example of a hypoelliptic FitzHugh—Nagumo model.","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"unknown: note\nThe most convenient way of smoothing diffusion trajectories is to use the DiffusionMCMC.jl package. For the pedagogical purposes we explain how to do it without this package, using solely DiffusionDefinition.jl, ObservationSchemes.jl and GuidedProposals.jl.","category":"page"},{"location":"tutorials/smoothing/#Introduction-1","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Introduction","text":"","category":"section"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"FitzHugh—Nagumo model is given by the following system of ODEs:","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"beginalign*\nfracdddd t y(t) = frac1ϵleft( y(t) - y^3(t)-x(t) + s right )\nfracdddd t x(t) = γ y(t) - x(t) + β\nendalign*","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"where (ϵ s γ β) are the model parameters. A stochastic version of this model is obtained by adding a Wiener noise to top, bottom or both terms above. For this tutorial we consider the following hypoelliptic stochastic differential equation corresponding to a stochastic version of the FitzHugh–Nagumo model:","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"beginalign*\ndd Y_t = frac1epsilonleft( Y_t - Y_t^3-X_t + s right )dd t\ndd X_t = left( gamma Y_t - X_t + beta right )dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"where σ0 is an additional parameter.","category":"page"},{"location":"tutorials/smoothing/#Prerequisites-1","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"In order to run this tutorial we need the following packages","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"using GuidedProposals, DiffusionDefinition, ObservationSchemes\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\n\nusing StaticArrays, Random, Plots","category":"page"},{"location":"tutorials/smoothing/#Data-generation-1","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Data generation","text":"","category":"section"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"FitzHugh–Nagumo model is—among other things—used in neuroscience to model the evolution of membrane potential of neurons. We could apply this tutorial to this type of data—i.e. recording of membrane potential of some neurons, but to keep the tutorial self-contained and simple we will simply generate the data from the model using some fixed, reasonable values for the parameters.","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"The model is already pre-defined for us and it can be loaded-in using DiffusionDefinition.jl.","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"@load_diffusion FitzHughNagumo","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"Reasonable parameter values that we use over and over again with the FitzHugh–Nagumo model for the purpose of explaining various aspect of the package are:","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"θ = [0.1, -0.8, 1.5, 0.0, 0.3]","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"Let's initialize the law and sample it over an interval 010.","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"P = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"And let's suppose that we observe the first coordinate of the process every 01 units of time, subject to some Gaussian noise.","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"data = map(\n    x->(x[1], x[2][1] + 0.1randn()),\n    collect(zip(X.t, X.x))[1:1000:end]\n)[2:end]","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"Let's visualize what we've sampled","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"# let's examine the data\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(map(x->x[1], data), map(x->x[2], data), label=\"data\")","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"(Image: data)","category":"page"},{"location":"tutorials/smoothing/#Data-preparation-1","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Data preparation","text":"","category":"section"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"Before we can start thinking about smoothing we must prepare the data. This boils down to","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"decorating every observation with appropriate information regarding how the data point was collected\nadding necessary information about the underlying law of the process\nadding information about the starting point","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"This can be easily accomplished using some of the functionality from the package ObservationSchemes.jl, as follows:","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"recording = (\n    P = P, # diffusion law\n    obs = load_data(\n        ObsScheme(\n            LinearGsnObs(\n                0.0, (@SVector [0.0]); # dummy variables indicating datatype of observations\n                L=(@SMatrix [1.0 0.0]), # observation operator\n                Σ=(@SMatrix [0.01]) # noise on the observations\n            )\n        ),\n        data\n    ),\n    t0 = 0.0,\n    x0_prior = KnownStartingPt(y1),\n)","category":"page"},{"location":"tutorials/smoothing/#Smoothing-algorithm-1","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing algorithm","text":"","category":"section"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"To do smoothing we will need to","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"initialize structs of GuidProp that will define the laws of guided proposals\nrepeatedly sample the trajectories of those GuidProp and compute their log-likelihoods\nembed the sampler above inside a Metropolis–Hastings algorithm","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"Instead of writing everything in a single routine, as is done in a how-to-guide for simplicity, we will define some structs to make our code look a bit nicer, as well as do some ground work for the subsequent tutorials.","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"We can define a Workspace which will contain all containers that are needed to sample from guided proposals.","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"mutable struct Workspace{GP,TX,TW,TWnr,Ty1}\n    PP::Vector{GP}\n    XX::Vector{TX}\n    XX°::Vector{TX}\n    WW::Vector{TW}\n    WW°::Vector{TW}\n    ρ::Float64\n    Wnr::TWnr\n    y1::Ty1\n\n    function Workspace(AuxLaw, recording, dt, ρ)\n        # time-grids for the forward-simulation of trajectories\n        tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n        # laws of guided proposals\n        PP = build_guid_prop(AuxLaw, recording, tts)\n\n        y1 = rand(recording.x0_prior)\n        # initialize the `accepted` trajectory\n        XX, WW, Wnr = rand(PP, y1)\n        # initialize the containers for the `proposal` trajectory\n        XX°, WW° = trajectory(PP)\n\n        # initialize the workspace\n        new{eltype(PP),eltype(XX),eltype(WW),typeof(Wnr),typeof(y1)}(\n            PP, XX, XX°, WW, WW°, ρ, Wnr, y1\n        )\n    end\nend","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"We can also define two functions for Workspace: one which samples a proposal trajectory using a preconditioned Crank—Nicolson scheme and computes the log-likelihood, and another, that swaps relevant containers in an event that the proposal is accepted:","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"function draw_proposal!(ws::Workspace)\n    _, ll° = rand!(\n        ws.PP, ws.XX°, ws.WW°, ws.WW, ws.ρ, Val(:ll), ws.y1;\n        Wnr=ws.Wnr\n    )\n    ll°\nend\n\nfunction swap_paths!(ws::Workspace)\n    ws.XX, ws.XX° = ws.XX°, ws.XX\n    ws.WW, ws.WW° = ws.WW°, ws.WW\nend","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"We can now define a smoothing algorithm very easily:","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"function simple_smoothing(AuxLaw, recording, dt; ρ=0.5, num_steps=10^4)\n    ws = Workspace(AuxLaw, recording, dt, ρ)\n    ll = loglikhd(ws.PP, ws.XX)\n    paths = []\n    num_accpt = 0\n\n    # MCMC\n    for i in 1:num_steps\n        # impute a path\n        ll° = draw_proposal!(ws)\n        # Metropolis–Hastings accept/reject step\n        if rand() < exp(ll°-ll)\n            swap_paths!(ws)\n            ll = ll°\n            num_accpt += 1\n        end\n\n        # progress message\n        if i % 100 == 0\n            println(\"$i. ll=$ll, acceptance rate: $(num_accpt/100)\")\n            num_accpt = 0\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(ws.XX)])\n    end\n    paths\nend","category":"page"},{"location":"tutorials/smoothing/#Running-the-algorithm-1","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Running the algorithm","text":"","category":"section"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"To run the algorithm we need to load-in a pre-defined auxiliary law and the simply call the main routine","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"@load_diffusion FitzHughNagumoAux\npaths = simple_smoothing(\n    FitzHughNagumoAux, recording, 0.001; ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"That's it! It takes about 6 seconds to run on my laptop.","category":"page"},{"location":"tutorials/smoothing/#Results-1","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Results","text":"","category":"section"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"To inspect the results we need to plot the returned paths. To visualize multiple paths defined over multiple intervals it is wise to first reduce the number of individual objects passed to plotting functions by grouping together objects that will end up looking indistinguishable on the canvas anyway. For us, this refers to segments of paths on each sub-interval. This can be done as follows:","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"function glue_paths(XX)\n    XX_glued = trajectory(\n        glue_containers( map(x->x.t, XX) ),\n        glue_containers( map(x->x.x, XX) ),\n    )\nend\n\nfunction glue_containers(xs)\n    glued_xs = collect(Iterators.flatten(map(x->x[1:end-1], xs)))\n    append!(glued_xs, [xs[end][end]])\n    glued_xs\nend\n\nconvenient_paths = glue_paths.(paths)","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"We may now visualize the results very simply:","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"col = [\"#581845\", \"#900C3F\", \"#C70039\", \"#FF5733\", \"#FFC300\"]\n\np = plot(size=(1000, 500))\nfor path in convenient_paths\n\tplot!(p, path, Val(:vs_time), alpha=0.4, label=\"\", color=[col[3] col[1]])\nend\nplot!(X, Val(:vs_time), color=[col[5] col[4]], linewidth=[3 0.5], label=[\"underlying X₁\" \"underlying X₂\"])\nscatter!(p, map(x->x[1], data), map(x->x[2], data), label=\"data\", markercolor=col[5])\ndisplay(p)","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"(Image: paths)","category":"page"},{"location":"tutorials/smoothing/#Concluding-remarks-1","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Concluding remarks","text":"","category":"section"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"TODO","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"tip: Tip\nIt should be straightforward to extend this tutorial to other diffusion laws.","category":"page"},{"location":"tutorials/smoothing/#Full-code-from-the-tutorial-1","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Full code from the tutorial","text":"","category":"section"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"","category":"page"},{"location":"tutorials/smoothing/#","page":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","title":"Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion","text":"using GuidedProposals, DiffusionDefinition, ObservationSchemes\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\n\nusing StaticArrays, Random, Plots\n\n# seed used for this tutorial\nRandom.seed!(100)\n\n@load_diffusion FitzHughNagumo\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\ndata = map(\n\tx->(x[1], x[2][1] + 0.1randn()),\n\tcollect(zip(X.t, X.x))[1:1000:end]\n)[2:end]\n\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(map(x->x[1], data), map(x->x[2], data), label=\"data\")\n\nrecording = (\n    P = P, # diffusion law\n    obs = load_data(\n        ObsScheme(\n            LinearGsnObs(\n                0.0, (@SVector [0.0]); # dummy variables indicating datatype of observations\n                L=(@SMatrix [1.0 0.0]), # observation operator\n                Σ=(@SMatrix [0.01]) # noise on the observations\n            )\n        ),\n        data\n    ),\n    t0 = 0.0,\n    x0_prior = KnownStartingPt(y1),\n)\n\nmutable struct Workspace{GP,TX,TW,TWnr,Ty1}\n    PP::Vector{GP}\n    XX::Vector{TX}\n    XX°::Vector{TX}\n    WW::Vector{TW}\n    WW°::Vector{TW}\n    ρρ::Vector{Float64}\n    Wnr::TWnr\n    y1::Ty1\n\n    function Workspace(AuxLaw, recording, dt, ρ)\n        # time-grids for the forward-simulation of trajectories\n        tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n        # memory parameters for the preconditioned Crank-Nicolson scheme\n        ρρ = [ρ for _ in tts]\n        # laws of guided proposals\n        PP = build_guid_prop(AuxLaw, recording, tts)\n\n        y1 = rand(recording.x0_prior)\n        # initialize the `accepted` trajectory\n        XX, WW, Wnr = rand(PP, y1)\n        # initialize the containers for the `proposal` trajectory\n        XX°, WW° = trajectory(PP)\n\n        # initialize the workspace\n        new{eltype(PP),eltype(XX),eltype(WW),typeof(Wnr),typeof(y1)}(\n            PP, XX, XX°, WW, WW°, ρρ, Wnr, y1\n        )\n    end\nend\n\nfunction draw_proposal!(ws::Workspace)\n    _, ll° = rand!(\n        ws.PP, ws.XX°, ws.WW°, ws.WW, ws.ρρ, Val(:ll), ws.y1;\n        Wnr=ws.Wnr\n    )\n    ll°\nend\n\nfunction swap_paths!(ws::Workspace)\n    ws.XX, ws.XX° = ws.XX°, ws.XX\n    ws.WW, ws.WW° = ws.WW°, ws.WW\nend\n\nfunction simple_smoothing(AuxLaw, recording, dt; ρ=0.5, num_steps=10^4)\n    ws = Workspace(AuxLaw, recording, dt, ρ)\n    ll = loglikhd(ws.PP, ws.XX)\n    paths = []\n    num_accpt = 0\n\n    # MCMC\n    for i in 1:num_steps\n        # impute a path\n        ll° = draw_proposal!(ws)\n        # Metropolis–Hastings accept/reject step\n        if rand() < exp(ll°-ll)\n            swap_paths!(ws)\n            ll = ll°\n            num_accpt += 1\n        end\n\n        # progress message\n        if i % 100 == 0\n            println(\"$i. ll=$ll, acceptance rate: $(num_accpt/100)\")\n            num_accpt = 0\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(ws.XX)])\n    end\n    paths\nend\n\n@load_diffusion FitzHughNagumoAux\npaths = simple_smoothing(\n    FitzHughNagumoAux, recording, 0.001; ρ=0.96, num_steps=10^4\n)\n\nfunction glue_paths(XX)\n    XX_glued = trajectory(\n        glue_containers( map(x->x.t, XX) ),\n        glue_containers( map(x->x.x, XX) ),\n    )\nend\n\nfunction glue_containers(xs)\n    glued_xs = collect(Iterators.flatten(map(x->x[1:end-1], xs)))\n    append!(glued_xs, [xs[end][end]])\n    glued_xs\nend\n\nconvenient_paths = glue_paths.(paths)\n\ncol = [\"#581845\", \"#900C3F\", \"#C70039\", \"#FF5733\", \"#FFC300\"]\n\np = plot(size=(1000, 500))\nfor path in convenient_paths\n\tplot!(p, path, Val(:vs_time), alpha=0.4, label=\"\", color=[col[3] col[1]])\nend\nplot!(X, Val(:vs_time), color=[col[5] col[4]], linewidth=[3 0.5], label=[\"underlying X₁\" \"underlying X₂\"])\nscatter!(p, map(x->x[1], data), map(x->x[2], data), label=\"data\", markercolor=col[5])\ndisplay(p)","category":"page"},{"location":"manual/path_functionals/#Computing-path-functionals-1","page":"Computing path functionals","title":"Computing path functionals","text":"","category":"section"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"","category":"page"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"This package uses the Euler-Maruyama solvers implemented in DiffusionDefinition.jl to sample diffusion trajectories. Consequently, in the same way that in the latter package it has been possible to compute path functionals whilst sampling, it is possible to do so for the conditioned trajectories of guided proposals sampled with this package as well.","category":"page"},{"location":"manual/path_functionals/#Sampling-over-a-single-interval-1","page":"Computing path functionals","title":"Sampling over a single interval","text":"","category":"section"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"","category":"page"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"To compute a functional when sampling over a single interval simply pass a named argument f=... with a function you wish to evaluate. The function that you pass must have the following methods defined for it:","category":"page"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"# called at the very start of solve!\nf_accum = foo(P, y)\n# called at the beginning of every iteration of the Euler-Maruyama scheme\nf_accum = foo(f_accum, P, y, t, dt, dW, i)\n# called at the very end, just before return statement\nf_accum = foo(f_accum, P, y, Val(:final))","category":"page"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"For in-place computations these three functions must have a slightly different form","category":"page"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"# called at the very start of solve!\nf_accum = foo(buffer, P, y) # the buffer needs to accommodate the needs of function f\n# called at the beginning of every iteration of the Euler-Maruyama scheme\nfoo(buffer, P, y, tt[i-1], dt, i-1)\n# called at the very end, just before return statement\nfoo(buffer, P, y, _FINAL)","category":"page"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"You may pass it to rand or rand! so long as Val(:ll) is not passed (i.e. so long as you are not calling optimized sampler that already computes the log-likelihood for you).","category":"page"},{"location":"manual/path_functionals/#Sampling-over-multiple-intervals-1","page":"Computing path functionals","title":"Sampling over multiple intervals","text":"","category":"section"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"","category":"page"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"To compute functionals when sampling over multiple intervals, instead of passing a single method as a named argument f=... pass a list of methods, say f=[foo₁,foo₂,foo₃], one for each interval. Additionally, pass an extra container to a named argument f_out. The results of method evaluation on each interval are going to be saved there.","category":"page"},{"location":"manual/path_functionals/#Computing-gradients-of-path-functionals-1","page":"Computing path functionals","title":"Computing gradients of path functionals","text":"","category":"section"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"","category":"page"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"Just as it was described in DiffusionDefinition.jl, it is possible to compute gradients while sampling.","category":"page"},{"location":"manual/path_functionals/#","page":"Computing path functionals","title":"Computing path functionals","text":"warning: TODO\nComplete the description.","category":"page"},{"location":"tutorials/parameter_inference/#Parameter-inference-on-the-example-of-the-FitzHugh-Nagumo-model-1","page":"Parameter inference","title":"Parameter inference on the example of the FitzHugh-Nagumo model","text":"","category":"section"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"In this tutorial we will explain how to perform Bayesian inference via MCMC sampling with GuidedProposals.jl on the example of the FitzHugh-Nagumo model. We will write a Metropolis-within-Gibbs algorithm that alternately imputes the unobserved path and updates unknown parameter. We will conduct inference for a single parameter, but it will be clear how to extend this tutorial to multiple parameters.","category":"page"},{"location":"tutorials/parameter_inference/#Introduction-1","page":"Parameter inference","title":"Introduction","text":"","category":"section"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"","category":"page"},{"location":"tutorials/parameter_inference/#Prerequisites-1","page":"Parameter inference","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"using GuidedProposals, DiffusionDefinition, ObservationSchemes\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\n\nusing StaticArrays, Random, Plots","category":"page"},{"location":"tutorials/parameter_inference/#Data-generation-1","page":"Parameter inference","title":"Data generation","text":"","category":"section"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"@load_diffusion FitzHughNagumo\n# generate some data\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\ndata = map(\n\tx->(x[1], x[2][1] + 0.1randn()),\n\tcollect(zip(X.t, X.x))[1:1000:end]\n)[2:end]\n#TODO introduce data collection in `ObservationSchemes.jl` with `ObsScheme()` object","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"# let's examine the data\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(map(x->x[1], data), map(x->x[2], data), label=\"data\")","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"(Image: data)","category":"page"},{"location":"tutorials/parameter_inference/#Data-preparation-1","page":"Parameter inference","title":"Data preparation","text":"","category":"section"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"# let's prepare the data\nrecording = (\n\tP = FitzHughNagumo([0.1, #==# 0.0 #==#, 1.5, 0.0, 0.3]...),\n\tobs = load_data(\n\t\tObsScheme(\n\t\t\tLinearGsnObs(\n\t\t\t\t0.0, (@SVector [0.0]);\n\t\t\t\tL=(@SMatrix [1.0 0.0]), Σ=(@SMatrix [0.01])\n\t\t\t)\n\t\t),\n\t\tdata\n\t),\n\tt0 = 0.0,\n\tx0_prior = KnownStartingPt(y1),\n)","category":"page"},{"location":"tutorials/parameter_inference/#Inference-algorithm-1","page":"Parameter inference","title":"Inference algorithm","text":"","category":"section"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"# define a simple transition kernel\nfunction customkernel(θ, s::Symbol, scale=0.1)\n\tθ° = deepcopy(θ)\n\tθ°[s] += 2.0*scale*(rand()-0.5)\n\tθ°\nend\n\n# and define a function that does the inference\nfunction simple_inference(AuxLaw, recording, dt, θ; ρ=0.5, num_steps=10^4)\n\t# initializations\n\ttts = OBS.setup_time_grids(recording, dt)\n\tPP = build_guid_prop(AuxLaw, recording, tts)\n\tPP° = deepcopy(PP)\n\n\ty1 = rand(recording.x0_prior) # just returns the starting point\n\tXX, WW, Wnr = rand(PP, y1)\n\tXX°, WW° = trajectory(PP)\n\n\tll = loglikhd(PP, XX)\n\tpaths = []\n\tθθ = Float64[θ[:s],]\n\timp_a_r = 0\n\tparam_a_r = 0\n\n\t# MCMC\n\tfor i in 1:num_steps\n\t\t# impute a path\n\t\t_, ll° = rand!(PP, XX°, WW°, WW, ρ, Val(:ll), y1; Wnr=Wnr)\n\n\t\tif rand() < exp(ll°-ll)\n\t\t\tXX, WW, XX°, WW° = XX°, WW°, XX, WW\n\t\t\tll = ll°\n\t\t\timp_a_r += 1\n\t\tend\n\n\t\t# update parameter s\n\t\tθ° = customkernel(θ, :s, 0.3)\n\t\tDD.set_parameters!(PP°, θ°)\n\t\trecompute_guiding_term!(PP°)\n\t\t_, ll° = GP.solve_and_ll!(XX°, WW, PP°, y1)\n\n\t\tif rand() < exp(ll°-ll) # uniform updates have no contribution to ll\n\t\t\tXX, PP, θ, XX°, PP°, θ° = XX°, PP°, θ°, XX, PP, θ\n\t\t\tll = ll°\n\t\t\tparam_a_r += 1\n\t\tend\n\t\tappend!(θθ, [θ[:s]])\n\n\n\t\t# progress message\n\t\tif i % 100 == 0\n\t\t\tprintln(\n\t\t\t\t\"$i. ll=$ll, s=$(θ[:s]), imp accpt rate: $(imp_a_r/100), \",\n\t\t\t\t\"updt accpt rate: $(param_a_r/100)\"\n\t\t\t)\n\t\t\timp_a_r = param_a_r = 0\n\t\tend\n\n\t\t# save intermediate path for plotting\n\t\ti % 400 == 0 && append!(paths, [deepcopy(XX)])\n\tend\n\tpaths, θθ\nend","category":"page"},{"location":"tutorials/parameter_inference/#Performing-inference-1","page":"Parameter inference","title":"Performing inference","text":"","category":"section"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"@load_diffusion FitzHughNagumoAux\n# let's declare which parameters are not changing\nDD.const_parameter_names(::Type{<:FitzHughNagumo}) = (:ϵ, :γ, :β, :σ)\nDD.const_parameter_names(::Type{<:FitzHughNagumoAux}) = (:ϵ, :γ, :β, :σ, :t0, :T, :vT, :xT)\n\n# and do the inference\npaths, θθ = simple_inference(\n\tFitzHughNagumoAux, recording, 0.001, Dict(:s=>0.0); ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"It takes about 45sec on my laptop...","category":"page"},{"location":"tutorials/parameter_inference/#Examining-the-results-1","page":"Parameter inference","title":"Examining the results","text":"","category":"section"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"plot(θθ)","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"(Image: fhn_mcmc_chain)","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"p = plot(size=(1400, 800))\nfor path in paths[end-10:end]\n\tfor i in eachindex(path)\n\t\tplot!(p, path[i], Val(:vs_time), alpha=0.4, label=\"\", color=[\"red\" \"steelblue\"])\n\tend\nend\nscatter!(p, map(x->x[1], data), map(x->x[2], data), label=\"data\")\ndisplay(p)","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"(Image: paths)","category":"page"},{"location":"tutorials/parameter_inference/#","page":"Parameter inference","title":"Parameter inference","text":"tip: Tip\nAdjusting the code presented in this tutorial to other diffusion processes, observation schemes or flavors of MCMC algorithm should be fairly straightforward, albeit can become tedious. Package DiffusionMCMC.jl (currently under development) has been designed precisely with this in mind and aims to remove the unnecessary, tedious work from the user when performing MCMC inference.","category":"page"},{"location":"how_to_guides/blocking/#how_to_do_blocking-1","page":"...do blocking","title":"How to do blocking?","text":"","category":"section"},{"location":"how_to_guides/blocking/#","page":"...do blocking","title":"...do blocking","text":"","category":"page"},{"location":"how_to_guides/blocking/#","page":"...do blocking","title":"...do blocking","text":"Blocking is a technique that modifies smoothing algorithms and facilitates more efficient exploration of the path space. A path is updated in blocks instead of being imputed in full. Blocking and the preconditioned Crank-Nicolson scheme both aim to achieve the same goal, but the two approaches differ in execution.","category":"page"},{"location":"how_to_guides/blocking/#","page":"...do blocking","title":"...do blocking","text":"# Perform smoothing for the data in the `recording`, using Guided Proposals with\n# the auxiliary law `AuxLaw` and using a blocking technique based on three\n# artificial observations.\nfunction simple_smoothing_with_blocking(\n        AuxLaw, recording, dt;\n        ρ=0.5, num_steps=10^4, AuxLawBlocking=AuxLaw, artificial_noise=1e-6\n    )\n    # -------------------------------------------------------------------------#\n    #                          Initializations                                 #\n    # -------------------------------------------------------------------------#\n    # time-grids for the forward-simulation of trajectories                    #\n    # we pass a time-transformation for improved accuracy                      #\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)  #\n    # laws of guided proposals (without any blocking)                          #\n    PP = build_guid_prop(AuxLaw, recording, tts)                               #\n                                                                               #\n    # starting point                                                           #\n    # NOTE `rand` for `KnownStartingPt` simply returns the starting position   #\n    y1 = rand(recording.x0_prior)                                              #\n    # initialize the `accepted` trajectory                                     #\n    XX, WW, Wnr = rand(PP, y1)                                                 #\n    # initialize the containers for the `proposal` trajectory                  #\n    XX°, WW° = trajectory(PP)                                                  #\n                                                                               #\n    paths = []                                                                 #\n    num_accpt = 0                                                              #\n    # -------------------------------------------------------------------------#\n\n\n    #--------------------------------------------------------------------------#\n    #                          Blocking setup                                  #\n    #--------------------------------------------------------------------------#\n    # let's do some very simple blocking based on three points                 #\n                                                                               #\n    # place three ~equidistant points                                          #\n    num_intv = length(PP)                                                      #\n    one_quarter_pt = div(num_intv, 4)                                          #\n    one_half_pt = div(num_intv, 2)                                             #\n    three_quarter_pt = one_half_pt + one_quarter_pt                            #\n                                                                               #\n    # define helper functions to build views to the relevant sections          #\n    # of PP, XX, etc. corresponding to different blocks                        #\n    block_set_1_builder(x, offset=0) = [                                       #\n        view(x, 1:(one_half_pt-offset)),                                       #\n        view(x, (one_half_pt+1):length(x))                                     #\n    ]                                                                          #\n    block_set_2_builder(x, offset=0) = [                                       #\n        view(x, 1:(one_quarter_pt-offset)),                                    #\n        view(x, (one_quarter_pt+1):(three_quarter_pt-offset)),                 #\n        view(x, (three_quarter_pt+1):length(x))                                #\n    ]                                                                          #\n    make_block_set(f, num_ρ=2) = (                                             #\n        PP = f(PP, 1),                                                         #\n        XX = f(XX),                                                            #\n        XX° = f(XX°),                                                          #\n        WW = f(WW),                                                            #\n        WW° = f(WW°),                                                          #\n        ρρ = fill(ρ, num_ρ),                                                   #\n    )                                                                          #\n                                                                               #\n    # define two sets of blocks                                                #\n    B1 = make_block_set(block_set_1_builder)                                   #\n    B2 = make_block_set(block_set_2_builder, 3)                                #\n                                                                               #\n    # define guided proposals on the last interval of each block               #\n    artif_PP1 = [                                                              #\n        guid_prop_for_blocking(B1.PP[1][end], AuxLawBlocking, artificial_noise)#\n    ]                                                                          #\n    artif_PP2 = collect([                                                      #\n        guid_prop_for_blocking(B2.PP[i][end], AuxLawBlocking, artificial_noise)#\n        for i in 1:2                                                           #\n    ])                                                                         #\n                                                                               #\n    num_accpt = [[0,0], [0,0,0]]                                               #\n    lls = [[0.0, 0.0], [0.0, 0.0, 0.0]]                                        #\n    #--------------------------------------------------------------------------#\n\n    # MCMC\n    for i in 1:num_steps\n        #  -----------------------\n        #  | imputation on SET 1 |\n        #  -----------------------\n        # set an auxiliary point\n        set_obs!(artif_PP1[1], B1.XX[1][end].x[end])\n        # the guiding term must be recomputed...\n        recompute_guiding_term!(B1.PP[1], artif_PP1[1])\n        recompute_guiding_term!(B1.PP[2])\n\n        # find a Wiener path W reconstructing the trajectory X\n        for j in 1:2\n            for k in 1:length(B1.PP[j])\n                DD.invsolve!(B1.XX[j][k], B1.WW[j][k], B1.PP[j][k])\n            end\n            # on block 1 the last guided proposal is removed from B1.PP[1]\n            # and instead the artif_PP1[1] must be used\n            j==1 && DD.invsolve!(B1.XX[j][end], B1.WW[j][end], artif_PP1[1])\n        end\n\n        y = y1\n        # impute the path\n        for j in 1:2 # there are two blocks in the first set\n\n            # sample a path on a given block\n            _, ll° = rand!(\n                B1.PP[j], B1.XX°[j], B1.WW°[j], B1.WW[j], B1.ρρ[j], Val(:ll), y;\n                Wnr=Wnr\n            )\n\n            # on the first block sample the last segment using a different law\n            if (j==1)\n                y = B1.XX°[j][end-1].x[end]\n                _, ll°_last = rand!(\n                    artif_PP1[1], B1.XX°[j][end], B1.WW°[j][end], B1.WW[j][end],\n                    B1.ρρ[j], Val(:ll), y; Wnr=Wnr\n                )\n                ll° += ll°_last\n            end\n\n            # compute log-likelihood on this interval for the accepted path\n            ll = loglikhd(B1.PP[j], B1.XX[j])\n            if (j==1) # on the first block the last segment has a different law\n                ll += loglikhd(artif_PP1[1], B1.XX[j][end])\n            end\n\n            lls[1][j] = ll # save for printing\n            if rand() < exp(ll°-ll)\n                for k in eachindex(B1.XX[j])\n                    B1.XX[j][k], B1.XX°[j][k] = B1.XX°[j][k], B1.XX[j][k]\n                    B1.WW[j][k], B1.WW°[j][k] = B1.WW°[j][k], B1.WW[j][k]\n                end\n                num_accpt[1][j] += 1\n                lls[1][j] = ll°\n            end\n            y = B1.XX[j][end].x[end]\n        end\n\n\n        #  -----------------------\n        #  | imputation on SET 2 |\n        #  -----------------------\n        # set auxiliary points\n        for j in 1:2\n            set_obs!(artif_PP2[j], B2.XX[j][end].x[end])\n            recompute_guiding_term!(B2.PP[j], artif_PP2[j])\n        end\n        # B2.PP[3] does not need to be recomputed, but of course, can be for\n        # good measure\n        # recompute_guiding_term!(B2.PP[3])\n\n        # find a Wiener path W reconstructing the trajectory X\n        for j in 1:3\n            for k in 1:length(B2.PP[j])\n                DD.invsolve!(B2.XX[j][k], B2.WW[j][k], B2.PP[j][k])\n            end\n            j<3 && DD.invsolve!(B2.XX[j][end], B2.WW[j][end], artif_PP2[j])\n        end\n\n        y = y1\n        # impute the path\n        for j in 1:3 # there are three blocks in the second set\n\n            # sample a path on a given block\n            _, ll° = rand!(\n                B2.PP[j], B2.XX°[j], B2.WW°[j], B2.WW[j], B2.ρρ[j], Val(:ll), y;\n                Wnr=Wnr\n            )\n\n            # on the 1st & 2nd block sample the last segment with a different law\n            if (j<3)\n                y = B2.XX°[j][end-1].x[end]\n                _, ll°_last = rand!(\n                    artif_PP2[j], B2.XX°[j][end], B2.WW°[j][end], B2.WW[j][end],\n                    B2.ρρ[j], Val(:ll), y; Wnr=Wnr\n                )\n                ll° += ll°_last\n            end\n\n            # compute log-likelihood on this interval for the accepted path\n            ll = loglikhd(B2.PP[j], B2.XX[j])\n            if (j<3) # on the 1st & 2nd block the last segment has a different law\n                ll += loglikhd(artif_PP2[j], B2.XX[j][end])\n            end\n\n            lls[2][j] = ll\n            if rand() < exp(ll°-ll)\n                for k in eachindex(B2.XX[j])\n                    B2.XX[j][k], B2.XX°[j][k] = B2.XX°[j][k], B2.XX[j][k]\n                    B2.WW[j][k], B2.WW°[j][k] = B2.WW°[j][k], B2.WW[j][k]\n                end\n                num_accpt[2][j] += 1\n                lls[2][j] = ll°\n            end\n            y = B2.XX[j][end].x[end]\n        end\n\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. \",\n                \"ll₁₁=$(lls[1][1]) (ar₁₁=$(num_accpt[1][1]/100)), \",\n                \"ll₁₂=$(lls[1][2]) (ar₁₂=$(num_accpt[1][2]/100));  \",\n                \"ll₂₁=$(lls[2][1]) (ar₂₁=$(num_accpt[2][1]/100)), \",\n                \"ll₂₂=$(lls[2][2]) (ar₂₂=$(num_accpt[2][2]/100)), \",\n                \"ll₂₃=$(lls[2][3]) (ar₂₃=$(num_accpt[2][3]/100))\"\n            )\n            num_accpt[1] .= 0\n            num_accpt[2] .= 0\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(XX)])\n    end\n    paths\nend","category":"page"},{"location":"how_to_guides/blocking/#Example-1","page":"...do blocking","title":"Example","text":"","category":"section"},{"location":"how_to_guides/blocking/#","page":"...do blocking","title":"...do blocking","text":"We can apply the routine above to the example used also in the previous how-to-guide on smoothing. Before doing so however, we must additionally override the behaviour of nonhypo and nonhypo_σ functions from the package DiffusionDefinition.jl.","category":"page"},{"location":"how_to_guides/blocking/#","page":"...do blocking","title":"...do blocking","text":"@inline DD.nonhypo(x, P::FitzHughNagumo) = x[SVector{1,Int64}(2)]\n@inline DD.nonhypo_σ(t::Float64, x, P::FitzHughNagumo) = SMatrix{1,1,Float64}(P.σ)","category":"page"},{"location":"how_to_guides/blocking/#","page":"...do blocking","title":"...do blocking","text":"We are now ready to run the algorithm","category":"page"},{"location":"how_to_guides/blocking/#","page":"...do blocking","title":"...do blocking","text":"paths = simple_smoothing_with_blocking(\n    FitzHughNagumoAux, recording, 0.001; ρ=0.84, num_steps=10^4, artificial_noise=1e-12\n)","category":"page"},{"location":"how_to_guides/blocking/#","page":"...do blocking","title":"...do blocking","text":"(Image: paths) It takes about 50sec on my laptop.","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#tutorials_start-1","page":"(TODO) Understanding in-place vs out-of-place","title":"Understanding in-place vs out-of-place methods and how to call them","text":"","category":"section"},{"location":"how_to_guides/parameter_inference/#How-to-infer-diffusion-parameters-based-on-its-discrete-time-observations?-1","page":"...infer parameters","title":"How to infer diffusion parameters based on its discrete-time observations?","text":"","category":"section"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"","category":"page"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"The most convenient solution is to use the package DiffusionMCMC.jl. Below, we explain how to do it without this package, using solely DiffusionDefinition.jl, ObservationSchemes.jl and GuidedProposals.jl.","category":"page"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"Define some transition kernel for the parameter updates. We will use a simple random walker","category":"page"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"# define a simple transition kernel\nfunction customkernel(θ, s::Symbol, scale=0.1)\n    θ° = deepcopy(θ)\n    θ°[s] += 2.0*scale*(rand()-0.5)\n    θ°\nend","category":"page"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"The main routine","category":"page"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"# Perform inference on a single parameter for the data in the `recording`, using\n# Guided Proposals with the auxiliary law `AuxLaw`.\nfunction simple_inference(AuxLaw, recording, dt, θ; ρ=0.5, num_steps=10^4, ϵ=0.3)\n    # -------------------------------------------------------------------------#\n    #                          Initializations                                 #\n    # -------------------------------------------------------------------------#\n    # time-grids for the forward-simulation of trajectories                    #\n    tts = OBS.setup_time_grids(recording, dt)                                  #\n    # laws of guided proposals                                                 #\n    PP = build_guid_prop(AuxLaw, recording, tts)                               #\n    # laws of guided proposals for parameter proposals                         #\n    PP° = deepcopy(PP)                                                         #\n                                                                               #\n    # starting point                                                           #\n    # NOTE `rand` for `KnownStartingPt` simply returns the starting position   #\n    y1 = rand(recording.x0_prior)                                              #\n    # initialize the `accepted` trajectory                                     #\n    XX, WW, Wnr = rand(PP, y1)                                                 #\n    # initialize the containers for the `proposal` trajectory                  #\n    XX°, WW° = trajectory(PP)                                                  #\n                                                                               #\n    ll = loglikhd(PP, XX)                                                      #\n    paths = []                                                                 #\n    imp_num_accpt = 0                                                          #\n    param_num_accpt = 0                                                        #\n    pname = collect(keys(θ))[1]                                                #\n    θθ = Float64[θ[pname],]                                                    #\n    # -------------------------------------------------------------------------#\n\n    # MCMC\n    for i in 1:num_steps\n        # impute a path\n        _, ll° = rand!(PP, XX°, WW°, WW, ρ, Val(:ll), y1; Wnr=Wnr)\n\n        # Metropolis–Hastings accept/reject step\n        if rand() < exp(ll°-ll)\n            XX, WW, XX°, WW° = XX°, WW°, XX, WW\n            ll = ll°\n            imp_num_accpt += 1\n        end\n\n        # update parameter s\n        θ° = customkernel(θ, pname, ϵ)\n        DD.set_parameters!(PP°, θ°)\n        recompute_guiding_term!(PP°)\n        _, ll° = GP.solve_and_ll!(XX°, WW, PP°, y1)\n\n        if rand() < exp(ll°-ll) # uniform updates have no contribution to ll\n            XX, PP, θ, XX°, PP°, θ° = XX°, PP°, θ°, XX, PP, θ\n        ll = ll°\n        param_num_accpt += 1\n    end\n    append!(θθ, [θ[pname]])\n\n    # progress message\n    if i % 100 == 0\n        println(\n            \"$i. ll=$ll, $pname=$(θ[pname]), imp accpt rate: \",\n            \"$(imp_num_accpt/100), updt accpt rate: $(param_num_accpt/100)\"\n        )\n        imp_num_accpt = param_num_accpt = 0\n    end\n\n    # save intermediate path for plotting\n    i % 400 == 0 && append!(paths, [deepcopy(XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"how_to_guides/parameter_inference/#Example-1","page":"...infer parameters","title":"Example","text":"","category":"section"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"We can now infer a single parameter of FitzHugh–Nagumo model. Define which parameters will not change:","category":"page"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"DD.const_parameter_names(::Type{<:FitzHughNagumo}) = (:ϵ, :γ, :β, :σ)\nDD.const_parameter_names(::Type{<:FitzHughNagumoAux}) = (:ϵ, :γ, :β, :σ, :t0, :T, :vT, :xT)","category":"page"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"and then, run the inference","category":"page"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"paths, θθ = simple_inference(\n    FitzHughNagumoAux, recording, 0.001, Dict(:s=>0.0); ρ=0.96, num_steps=10^4, ϵ=0.3\n)","category":"page"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"It takes about 25sec on my laptop...","category":"page"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"The chain (truth used to generate the data is 08) (Image: fhn_mcmc_chain)","category":"page"},{"location":"how_to_guides/parameter_inference/#","page":"...infer parameters","title":"...infer parameters","text":"And the paths: (Image: paths)","category":"page"},{"location":"how_to_guides/sample_bridges/#how_to_guides-1","page":"(TODO) Sample diffusion bridges","title":"How to sample diffusion bridges","text":"","category":"section"},{"location":"tutorials/blocking/#Setting-up-a-blocking-scheme-for-a-simple-smoothing-problem-1","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"","category":"section"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"In this tutorial we will smooth trajectories of a diffusion process (based on discrete-time observations of its sampled trajectory) using guided proposals with a blocking scheme. We will apply the algorithm to an example of a hypoelliptic FitzHugh–Nagumo model.","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"unknown: note\nThe most convenient way of smoothing diffusion trajectories with blocking is to use the DiffusionMCMC.jl package. For the pedagogical purposes we explain how to do it without this package, using solely DiffusionDefinition.jl, ObservationSchemes.jl and GuidedProposals.jl.","category":"page"},{"location":"tutorials/blocking/#Introduction-1","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Introduction","text":"","category":"section"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"This tutorial is an extension of the previous tutorial on smoothing of diffusion trajectories. We use the same example and the same generated data. For more information about the model see the previous tutorial.","category":"page"},{"location":"tutorials/blocking/#Prerequisites,-data-generation-and-data-preparation-1","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Prerequisites, data generation and data preparation","text":"","category":"section"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"We need the same packages as last time. We will use the same data that we generated for the last tutorial. The preparation steps remain unchanged.","category":"page"},{"location":"tutorials/blocking/#Blocking-1","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Blocking","text":"","category":"section"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"Blocking is a technique of sampling diffusion trajectories where only segments of paths (as opposed to a full path) are ever updated at a time. The quickest way to understand it is to look at an animation","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"[TODO add animation]","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"[TODO add description]","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"Translated to computer code, each block will be represented by an appropriate view to the containers that are pertinent to the entire trajectory. More precisely, we should again have the same Workspace struct from the previous tutorial, but now, we should additionally have the struct Block that you can think of as a window that restricts a view to Workspace to certain segments. There is one additional detail. The last segment of each block is a tad special. The terminal observation on such an interval is not the observation from the dataset, but instead, an exact and artificial observation that corresponds to a value taken at a given time-point by the previously accepted trajectory. As a result, the GuidProp defined on this interval must have the observation field obs, as well as the auxiliary law P_aux appropriately modified. As these changes may in principle (and often would) break the type-stability of GuidProp, we must define a separate GuidProp that can handle exact observation and that will be used with blocking on a given interval. And a final–final detail, the last explanation applies to all final intervals of each block, with the exception of the last block. On the last block the terminal observation is never changed to an artificial one.","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"Consequently, the Block struct might look as follows:","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"const TVIEW{T} = SubArray{T,1,Array{T,1},Tuple{UnitRange{Int64}},true}\n\nmutable struct Block{GP,GPl,TX,TW,TWnr,Ty1}\n    PP::TVIEW{GP}\n    P_last::GPl\n    XX::TVIEW{TX}\n    XX°::TVIEW{TX}\n    WW::TVIEW{TW}\n    WW°::TVIEW{TW}\n    ρ::Float64\n    Wnr::TWnr\n    y1::Ty1\n\n    function Block(\n            ws::Workspace{GP,TX,TW,TWnr,Ty1},\n            range::UnitRange{Int64},\n            AuxLawBlocking,\n            artificial_noise=1e-11,\n            last_block=false,\n            ρ = ws.ρ\n        ) where {GP,TX,TW,TWnr,Ty1}\n        PP = view(ws.PP, range[1]:(range[end]-!last_block)) # omit the last law\n        P_last = (\n            last_block ?\n            nothing :\n            guid_prop_for_blocking(\n                ws.PP[range[end]], AuxLawBlocking, artificial_noise\n            )\n        )\n\n        XX = view(ws.XX, range)\n        XX° = view(ws.XX°, range)\n        WW = view(ws.WW, range)\n        WW° = view(ws.WW°, range)\n\n        new{GP,typeof(P_last),TX,TW,TWnr,Ty1}(\n            PP, P_last, XX, XX°, WW, WW°, ρ, ws.Wnr, deepcopy(ws.y1)\n        )\n    end\nend","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"As in the case of smoothing, we should also declare how the sampling of paths should look like, as well as how the containers should be swapped in case of acceptance. The first procedure will differ a little depending on whether we work with the last block or not:","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"# NOT the last block\nfunction draw_proposal!(b::Block)\n    # sample a path on a given block\n    _, ll° = rand!(b.PP, b.XX°, b.WW°, b.WW, b.ρ, Val(:ll), b.y1; Wnr=b.Wnr)\n    # sample the last segment using a different law\n    y = b.XX°[end-1].x[end]\n    _, ll°_last = rand!(\n        b.P_last, b.XX°[end], b.WW°[end], b.WW[end], b.ρ, Val(:ll), y;\n        Wnr=b.Wnr\n    )\n    ll° + ll°_last\nend\n\n# the last block\nfunction draw_proposal!(b::Block{GP,Nothing}) where GP\n    # sample a path on a given block\n    _, ll° = rand!(b.PP, b.XX°, b.WW°, b.WW, b.ρ, Val(:ll), b.y1; Wnr=b.Wnr)\n    ll°\nend\n\nfunction swap_paths!(b::Block)\n    for i in eachindex(b.XX)\n        b.XX[i], b.XX°[i] = b.XX°[i], b.XX[i]\n        b.WW[i], b.WW°[i] = b.WW°[i], b.WW[i]\n    end\nend","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"We could now go ahead and implement smoothing with blocking algorithm, but we can make our lives a tiny bit easier later on by writing some additional helper functions that work with blocks. First of, with blocking we must be able to set the artificial observation:","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"# we will be extending functions from GuidedProposals module, hence `GP.`\nGP.set_obs!(b::Block) = set_obs!(b.P_last, b.XX[end].x[end])\nGP.set_obs!(b::Block{T,Nothing}) where T = nothing","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"The artificial observation b.XX[end].x[end] will not only become the conditioned-on terminal observation in a given block, but also, it will become the starting position for the subsequent block. Let's define a function that sets the starting position as well:","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"reset_y1!(b::Block) = (b.y1 = b.XX[1].x[1])","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"Once the observation is set, we should also be able to recompute the guiding term. This re-computation will slightly differ depending on whether we are dealing with the last block or not","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"# NOT the last block\nGP.recompute_guiding_term!(b::Block) = recompute_guiding_term!(b.PP, b.P_last)\n\n# the last block\nfunction GP.recompute_guiding_term!(b::Block{T,Nothing}) where T\n    recompute_guiding_term!(b.PP)\nend","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"After re-computing the guiding term we should find the Wiener noise that reconstructs the already accepted path X for a given guiding term:","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"# NOT the last block\nfunction find_W_for_X!(b::Block)\n    for i in eachindex(b.PP)\n        DD.invsolve!(b.XX[i], b.WW[i], b.PP[i])\n    end\n    DD.invsolve!(b.XX[end], b.WW[end], b.P_last)\nend\n\n# the last block\nfunction find_W_for_X!(b::Block{GP,Nothing}) where GP\n    for i in eachindex(b.PP)\n        DD.invsolve!(b.XX[i], b.WW[i], b.PP[i])\n    end\nend","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"Finally, we should be able to re-evaluate the log-likelihood for the accepted path once the guiding term has changed:","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"# NOT the last block\nGP.loglikhd(b::Block) = loglikhd(b.PP, b.XX) + loglikhd(b.P_last, b.XX[end])\n\n# the last block\nGP.loglikhd(b::Block{T,Nothing}) where T = loglikhd(b.PP, b.XX)","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"We should be good to go.","category":"page"},{"location":"tutorials/blocking/#Smoothing-algorithm-with-blocking-1","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Smoothing algorithm with blocking","text":"","category":"section"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"function simple_smoothing_with_blocking(\n        AuxLaw, recording, dt;\n        ρ=0.5, num_steps=10^4, AuxLawBlocking=AuxLaw, artificial_noise=1e-6\n    )\n    ws = Workspace(AuxLaw, recording, dt, ρ)\n\n    #--------------------------------------------------------------------------#\n    #                          Blocking setup                                  #\n    #--------------------------------------------------------------------------#\n    # let's do some very simple blocking based on three points                 #\n                                                                               #\n    # place three ~equidistant points                                          #\n    num_intv = length(ws.PP)                                                   #\n    one_quarter_pt = div(num_intv, 4)                                          #\n    one_half_pt = div(num_intv, 2)                                             #\n    three_quarter_pt = one_half_pt + one_quarter_pt                            #\n                                                                               #\n    # alias                                                                    #\n    ϵ = artificial_noise                                                       #\n                                                                               #\n    # define two sets of blocks                                                #\n    B1 = [                                                                     #\n        Block(ws, 1:one_half_pt, AuxLaw, ϵ),                                   #\n        Block(ws, (one_half_pt+1):num_intv, AuxLaw, ϵ, true)                   #\n    ]                                                                          #\n    B2 = [                                                                     #\n        Block(ws, 1:one_quarter_pt, AuxLaw, ϵ),                                #\n        Block(ws, (one_quarter_pt+1):three_quarter_pt, AuxLaw, ϵ),             #\n        Block(ws, (three_quarter_pt+1):num_intv, AuxLaw, ϵ, true)              #\n    ]                                                                          #\n    sets_of_blocks = [B1, B2]                                                  #\n                                                                               #\n    num_accpt = [[0,0], [0,0,0]]                                               #\n    lls = [[0.0, 0.0], [0.0, 0.0, 0.0]]                                        #\n    #--------------------------------------------------------------------------#\n\n    # MCMC\n    for i in 1:num_steps\n        # iterate over sets of blocks\n        for (Bidx, B) in enumerate(sets_of_blocks)\n            # set auxiliary points\n            set_obs!.(B)\n\n            # the guiding term must be recomputed...\n            recompute_guiding_term!.(B)\n\n            # find a Wiener path W reconstructing the trajectory X\n            find_W_for_X!.(B)\n\n            # impute the path\n            for k in eachindex(B)\n                ll° = draw_proposal!(B[k])\n\n                # compute log-likelihood on this interval for the accepted path\n                ll = loglikhd(B[k])\n\n                lls[Bidx][k] = ll # save for printing\n                if rand() < exp(ll°-ll)\n                    swap_paths!(B[k])\n                    num_accpt[Bidx][k] += 1\n                    lls[Bidx][k] = ll°\n                end\n                # update the starting point on the subsequent block\n                (k<length(B)) && reset_y1!(B[k+1])\n            end\n        end\n\n        # progress message\n        if i % 100 == 0\n            msg = \"$i. \"\n            for j in eachindex(sets_of_blocks)\n                for k in eachindex(lls[j])\n                    msg = msg*\"ll_$j$k=$(lls[j][k]) (ar$j$k=$(num_accpt[j][k]/100)), \"\n                end\n            end\n            println(msg)\n            num_accpt[1] .= 0\n            num_accpt[2] .= 0\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(ws.XX)])\n    end\n    paths\nend","category":"page"},{"location":"tutorials/blocking/#Results-1","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Results","text":"","category":"section"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"Before applying the routine to the data we need to do one last step. FitzHugh–Nagumo diffusion is a type of a hypoelliptic diffusion with a degenerate noise structure. For this type of processes we need to declare the behaviour of two functions from the DiffusionDefinition.jl module: nonhypo and nonhypo_σ. The reason for this is additional requirement is a step of computing the Wiener path from the sampled trajectory X. Coordinates that have zero Wiener noise contribute nothing to the process of finding W from X, so we need to indicate to Julia which information is relevant for this step and which is not.","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"warning: Warning\nNote that we access a subvector of x using static arrays! This is very important if the state of your diffusion is represented with static arrays as well. Otherwise the output of nonhypo will be a regular vector, Julia will have to perform computations on a mix of regular and static vectors and your code will be unnecessarily slow!","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"@load_diffusion FitzHughNagumoAux\n@inline DD.nonhypo(x, P::FitzHughNagumo) = x[SVector{1,Int64}(2)]\n@inline DD.nonhypo_σ(t::Float64, x, P::FitzHughNagumo) = SMatrix{1,1,Float64}(P.σ)","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"We are ready to run the algorithm. It takes about 56seconds on my laptop.","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"paths = simple_smoothing_with_blocking(\n    FitzHughNagumoAux, recording, 0.001; ρ=0.84, num_steps=10^4, artificial_noise=1e-12\n)","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"note: Note\nIf you read through a how-to-guide on blocking, then you might have remembered that the code written there took only 50seconds to execute on my laptop. Where is the difference coming from? If you recall from the how-to-guide, we were a bit more verbatim and we decided not to recompute the guiding term on the last block from a second blocking set (as it will never change). We could do the same thing here, but instead, we opted for neatness of the code. If this step is performed also in the how-to-guide then both routines take the same amount of time to execute.","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"We can now view the paths in the same way as in the previous tutorial (Image: paths)","category":"page"},{"location":"tutorials/blocking/#Concluding-remarks-1","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Concluding remarks","text":"","category":"section"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"TODO","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"tip: Tip\nIt should be straightforward to extend this to different diffusion laws, as well as to different blocking scheme. How would you implement a random blocking scheme? (Hint: you need to remove P_last from the definition of Block to avoid re-allocations of memory).","category":"page"},{"location":"tutorials/blocking/#Full-code-from-the-tutorial-1","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Full code from the tutorial","text":"","category":"section"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"","category":"page"},{"location":"tutorials/blocking/#","page":"Setting up a blocking scheme for a simple smoothing problem","title":"Setting up a blocking scheme for a simple smoothing problem","text":"using GuidedProposals, DiffusionDefinition, ObservationSchemes\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\n\nusing StaticArrays, Random, Plots\n\n# seed used for this tutorial\nRandom.seed!(100)\n\n@load_diffusion FitzHughNagumo\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\ndata = map(\n\tx->(x[1], x[2][1] + 0.1randn()),\n\tcollect(zip(X.t, X.x))[1:1000:end]\n)[2:end]\n\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(map(x->x[1], data), map(x->x[2], data), label=\"data\")\n\nrecording = (\n    P = P, # diffusion law\n    obs = load_data(\n        ObsScheme(\n            LinearGsnObs(\n                0.0, (@SVector [0.0]); # dummy variables indicating datatype of observations\n                L=(@SMatrix [1.0 0.0]), # observation operator\n                Σ=(@SMatrix [0.01]) # noise on the observations\n            )\n        ),\n        data\n    ),\n    t0 = 0.0,\n    x0_prior = KnownStartingPt(y1),\n)\n\nmutable struct Workspace{GP,TX,TW,TWnr,Ty1}\n    PP::Vector{GP}\n    XX::Vector{TX}\n    XX°::Vector{TX}\n    WW::Vector{TW}\n    WW°::Vector{TW}\n    ρ::Float64\n    Wnr::TWnr\n    y1::Ty1\n\n    function Workspace(AuxLaw, recording, dt, ρ)\n        # time-grids for the forward-simulation of trajectories\n        tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n        # laws of guided proposals\n        PP = build_guid_prop(AuxLaw, recording, tts)\n\n        y1 = rand(recording.x0_prior)\n        # initialize the `accepted` trajectory\n        XX, WW, Wnr = rand(PP, y1)\n        # initialize the containers for the `proposal` trajectory\n        XX°, WW° = trajectory(PP)\n\n        # initialize the workspace\n        new{eltype(PP),eltype(XX),eltype(WW),typeof(Wnr),typeof(y1)}(\n            PP, XX, XX°, WW, WW°, ρ, Wnr, y1\n        )\n    end\nend\n\n#------------------------------------------------------------------------------#\n#                            START OF NEW CODE                                 #\n#------------------------------------------------------------------------------#\n\nconst TVIEW{T} = SubArray{T,1,Array{T,1},Tuple{UnitRange{Int64}},true}\n\nmutable struct Block{GP,GPl,TX,TW,TWnr,Ty1}\n    PP::TVIEW{GP}\n    P_last::GPl\n    XX::TVIEW{TX}\n    XX°::TVIEW{TX}\n    WW::TVIEW{TW}\n    WW°::TVIEW{TW}\n    ρ::Float64\n    Wnr::TWnr\n    y1::Ty1\n\n    function Block(\n            ws::Workspace{GP,TX,TW,TWnr,Ty1},\n            range::UnitRange{Int64},\n            AuxLawBlocking,\n            artificial_noise=1e-11,\n            last_block=false,\n            ρ = ws.ρ\n        ) where {GP,TX,TW,TWnr,Ty1}\n        PP = view(ws.PP, range[1]:(range[end]-!last_block)) # omit the last law\n        P_last = (\n            last_block ?\n            nothing :\n            guid_prop_for_blocking(\n                ws.PP[range[end]], AuxLawBlocking, artificial_noise\n            )\n        )\n\n        XX = view(ws.XX, range)\n        XX° = view(ws.XX°, range)\n        WW = view(ws.WW, range)\n        WW° = view(ws.WW°, range)\n\n        new{GP,typeof(P_last),TX,TW,TWnr,Ty1}(\n            PP, P_last, XX, XX°, WW, WW°, ρ, ws.Wnr, deepcopy(ws.y1)\n        )\n    end\nend\n\n# NOT the last block\nfunction draw_proposal!(b::Block)\n    # sample a path on a given block\n    _, ll° = rand!(b.PP, b.XX°, b.WW°, b.WW, b.ρ, Val(:ll), b.y1; Wnr=b.Wnr)\n    # sample the last segment using a different law\n    y = b.XX°[end-1].x[end]\n    _, ll°_last = rand!(\n        b.P_last, b.XX°[end], b.WW°[end], b.WW[end], b.ρ, Val(:ll), y;\n        Wnr=b.Wnr\n    )\n    ll° + ll°_last\nend\n\n# the last block\nfunction draw_proposal!(b::Block{GP,Nothing}) where GP\n    # sample a path on a given block\n    _, ll° = rand!(b.PP, b.XX°, b.WW°, b.WW, b.ρ, Val(:ll), b.y1; Wnr=b.Wnr)\n    ll°\nend\n\nfunction swap_paths!(b::Block)\n    for i in eachindex(b.XX)\n        b.XX[i], b.XX°[i] = b.XX°[i], b.XX[i]\n        b.WW[i], b.WW°[i] = b.WW°[i], b.WW[i]\n    end\nend\n\n# we will be extending functions from GuidedProposals module, hence `GP.`\nGP.set_obs!(b::Block) = set_obs!(b.P_last, b.XX[end].x[end])\nGP.set_obs!(b::Block{T,Nothing}) where T = nothing\nreset_y1!(b::Block) = (b.y1 = b.XX[1].x[1])\n# NOT the last block\nGP.recompute_guiding_term!(b::Block) = recompute_guiding_term!(b.PP, b.P_last)\n\n# the last block\nfunction GP.recompute_guiding_term!(b::Block{T,Nothing}) where T\n    recompute_guiding_term!(b.PP)\nend\n# NOT the last block\nfunction find_W_for_X!(b::Block)\n    for i in eachindex(b.PP)\n        DD.invsolve!(b.XX[i], b.WW[i], b.PP[i])\n    end\n    DD.invsolve!(b.XX[end], b.WW[end], b.P_last)\nend\n\n# the last block\nfunction find_W_for_X!(b::Block{GP,Nothing}) where GP\n    for i in eachindex(b.PP)\n        DD.invsolve!(b.XX[i], b.WW[i], b.PP[i])\n    end\nend\n\n# NOT the last block\nGP.loglikhd(b::Block) = loglikhd(b.PP, b.XX) + loglikhd(b.P_last, b.XX[end])\n\n# the last block\nGP.loglikhd(b::Block{T,Nothing}) where T = loglikhd(b.PP, b.XX)\n\nfunction simple_smoothing_with_blocking(\n        AuxLaw, recording, dt;\n        ρ=0.5, num_steps=10^4, AuxLawBlocking=AuxLaw, artificial_noise=1e-6\n    )\n    ws = Workspace(AuxLaw, recording, dt, ρ)\n    paths = []\n\n    #--------------------------------------------------------------------------#\n    #                          Blocking setup                                  #\n    #--------------------------------------------------------------------------#\n    # let's do some very simple blocking based on three points                 #\n                                                                               #\n    # place three ~equidistant points                                          #\n    num_intv = length(ws.PP)                                                   #\n    one_quarter_pt = div(num_intv, 4)                                          #\n    one_half_pt = div(num_intv, 2)                                             #\n    three_quarter_pt = one_half_pt + one_quarter_pt                            #\n                                                                               #\n    # alias                                                                    #\n    ϵ = artificial_noise                                                       #\n                                                                               #\n    # define two sets of blocks                                                #\n    B1 = [                                                                     #\n        Block(ws, 1:one_half_pt, AuxLaw, ϵ),                                   #\n        Block(ws, (one_half_pt+1):num_intv, AuxLaw, ϵ, true)                  #\n    ]                                                                          #\n    B2 = [                                                                     #\n        Block(ws, 1:one_quarter_pt, AuxLaw, ϵ),                                #\n        Block(ws, (one_quarter_pt+1):three_quarter_pt, AuxLaw, ϵ),             #\n        Block(ws, (three_quarter_pt+1):num_intv, AuxLaw, ϵ, true)             #\n    ]                                                                          #\n    sets_of_blocks = [B1, B2]                                                  #\n                                                                               #\n    num_accpt = [[0,0], [0,0,0]]                                               #\n    lls = [[0.0, 0.0], [0.0, 0.0, 0.0]]                                        #\n    #--------------------------------------------------------------------------#\n\n    # MCMC\n    for i in 1:num_steps\n        # iterate over sets of blocks\n        for (Bidx, B) in enumerate(sets_of_blocks)\n            # set auxiliary points\n            set_obs!.(B)\n\n            # the guiding term must be recomputed...\n            recompute_guiding_term!.(B)\n\n            # find a Wiener path W reconstructing the trajectory X\n            find_W_for_X!.(B)\n\n            # impute the path\n            for k in eachindex(B)\n                ll° = draw_proposal!(B[k])\n\n                # compute log-likelihood on this interval for the accepted path\n                ll = loglikhd(B[k])\n\n                lls[Bidx][k] = ll # save for printing\n                if rand() < exp(ll°-ll)\n                    swap_paths!(B[k])\n                    num_accpt[Bidx][k] += 1\n                    lls[Bidx][k] = ll°\n                end\n                # update the starting point on the subsequent block\n                (k<length(B)) && reset_y1!(B[k+1])\n            end\n        end\n\n        # progress message\n        if i % 100 == 0\n            msg = \"$i. \"\n            for j in eachindex(sets_of_blocks)\n                for k in eachindex(lls[j])\n                    msg = msg*\"ll_$j$k=$(lls[j][k]) (ar$j$k=$(num_accpt[j][k]/100)), \"\n                end\n            end\n            println(msg)\n            num_accpt[1] .= 0\n            num_accpt[2] .= 0\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(ws.XX)])\n    end\n    paths\nend\n\n\n@load_diffusion FitzHughNagumoAux\n@inline DD.nonhypo(x, P::FitzHughNagumo) = x[SVector{1,Int64}(2)]\n@inline DD.nonhypo_σ(t::Float64, x, P::FitzHughNagumo) = SMatrix{1,1,Float64}(P.σ)\n\npaths = simple_smoothing_with_blocking(\n    FitzHughNagumoAux, recording, 0.001; ρ=0.84, num_steps=10^4, artificial_noise=1e-12\n)\n\n#------------------------------------------------------------------------------#\n#                              END OF NEW CODE                                 #\n#------------------------------------------------------------------------------#\n\nfunction glue_paths(XX)\n    XX_glued = trajectory(\n        glue_containers( map(x->x.t, XX) ),\n        glue_containers( map(x->x.x, XX) ),\n    )\nend\n\nfunction glue_containers(xs)\n    glued_xs = collect(Iterators.flatten(map(x->x[1:end-1], xs)))\n    append!(glued_xs, [xs[end][end]])\n    glued_xs\nend\n\nconvenient_paths = glue_paths.(paths)\n\ncol = [\"#581845\", \"#900C3F\", \"#C70039\", \"#FF5733\", \"#FFC300\"]\n\np = plot(size=(1000, 500))\nfor path in convenient_paths\n\tplot!(p, path, Val(:vs_time), alpha=0.4, label=\"\", color=[col[3] col[1]])\nend\nplot!(X, Val(:vs_time), color=[col[5] col[4]], linewidth=[3 0.5], label=[\"underlying X₁\" \"underlying X₂\"])\nscatter!(p, map(x->x[1], data), map(x->x[2], data), label=\"data\", markercolor=col[5])\ndisplay(p)","category":"page"},{"location":"manual/ode_type/#ode_types-1","page":"(TODO) ODE systems","title":"ODE systems for computing the guiding term","text":"","category":"section"},{"location":"manual/ode_type/#","page":"(TODO) ODE systems","title":"(TODO) ODE systems","text":"","category":"page"},{"location":"manual/ode_type/#","page":"(TODO) ODE systems","title":"(TODO) ODE systems","text":"The guiding term can be computed in a variety of ways. Here, we provide four distinct methods—corresponding to three systems of ODEs and a direct method via evaluations of matrix exponentials—for achieving this feat.","category":"page"},{"location":"manual/ode_type/#","page":"(TODO) ODE systems","title":"(TODO) ODE systems","text":"warning: Warning\nCurrently only a method via solving ODEs for H, F and c has been implemented.","category":"page"},{"location":"manual/ode_type/#Exact-equations-1","page":"(TODO) ODE systems","title":"Exact equations","text":"","category":"section"},{"location":"manual/ode_type/#","page":"(TODO) ODE systems","title":"(TODO) ODE systems","text":"","category":"page"},{"location":"manual/ode_type/#System-of-ODEs-for-H,-F-and-c-1","page":"(TODO) ODE systems","title":"System of ODEs for H, F and c","text":"","category":"section"},{"location":"manual/ode_type/#","page":"(TODO) ODE systems","title":"(TODO) ODE systems","text":"","category":"page"},{"location":"manual/ode_type/#System-of-ODEs-for-M,-L-and-μ-1","page":"(TODO) ODE systems","title":"System of ODEs for M, L and μ","text":"","category":"section"},{"location":"manual/ode_type/#","page":"(TODO) ODE systems","title":"(TODO) ODE systems","text":"","category":"page"},{"location":"manual/ode_type/#System-of-ODEs-for-P,-\\nu-and-c-1","page":"(TODO) ODE systems","title":"System of ODEs for P, nu and c","text":"","category":"section"},{"location":"manual/ode_type/#","page":"(TODO) ODE systems","title":"(TODO) ODE systems","text":"","category":"page"},{"location":"manual/guid_prop/#manual_start-1","page":"Guided proposals","title":"Defining guided proposals","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"The main object used to define guided proposals is","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"GuidedProposals.GuidProp","category":"page"},{"location":"manual/guid_prop/#GuidedProposals.GuidProp","page":"Guided proposals","title":"GuidedProposals.GuidProp","text":"struct GuidProp{\n        K,DP,DW,SS,R,R2,O,S,T\n        } <: DiffusionDefinition.DiffusionProcess{K,DP,DW,SS}\n    P_target::R\n    P_aux::R2\n    obs::O\n    guiding_term_solver::S\nend\n\nStruct defining guided proposals of M Schauer, F van der Meulen and H van Zanten. See Mider M, Schauer M and van der Meulen F \"Continuous-discrete smoothing of diffusions\" (2020) for a comprehensive overview of the mathematics behind this object. It computes and stores the guiding term ∇logρ and allows for simulation of guided proposals and computation of their likelihood.\n\nGuidProp(\n        tt,\n        P_target::R,\n        P_aux_type::Type{TR2},\n        obs::O,\n        solver_choice=(\n            solver=Tsit5(),\n            ode_type=:HFc,\n            convert_to_HFc=false,\n            mode=:inplace,\n            gradients=false,\n            eltype=Float64,\n        ),\n        next_guided_prop=nothing,\n    ) where {\n        R<:DD.DiffusionProcess,\n        TR2<:DD.DiffusionProcess,\n        O<:OBS.Observation\n    }\n\nDefault constructor. P_target and P_aux are the target and the type of the auxiliary diffusion laws respectively, tt is the time-grid on which ∇logρ needs to be computed. obs is the terminal observation (and the only one on the interval (tt[1], tt[end]]). solver_choice specifies the type of ODE solver that is to be used for computations of ∇logρ     ( it is a NamedTuple, where solver specifies the algorithm for solving     ODEs (see the documentation of DifferentialEquations.jl for possible     choices), ode_type picks the ODE system (between :HFc, :MLμ and :Pν),     convert_to_HFc indicates whether to translate the results of M,L,μ solver     to H,F,c objects, mode is a flag indicating the way in which data is being     handled:     - :inplace: uses regular arrays to store the data (requires functions                   B!, β!, σ! and a! to be defined)     - :outofplace: operates on static arrays     - :gpu: operates on GPU arrays [TODO not implemented yet]     gradients is a flag indicating whether automatic differentiation is to     be employed and eltype indicates the data-type of each container's     member. ) Finally, next_guided_prop is the guided proposal for the subsequent inter-observation interval.\n\n\n\n\n\n","category":"type"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"The main role of this object is to facilitate sampling of diffusion paths from some target diffusion law by:","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"drawing from a proposal diffusion law &\ncomputing an importance sampling weight","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"Performing these two steps in a setting of importance sampling or mcmc sampling makes it possible to draw sample-paths from the target law.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"note: Note\nFrom the conceptual point of view, the target and auxiliary laws, as well as the terminal observations are all required to define a guided proposal. However, conceptually, guided proposals are defined as continuous-time processes, and thus, it should be possible to look-up the value of any sampled trajectory at any time tin0T. tt— the time grid on which the path is to be revealed—is thus conceptually superfluous at the time of initialization. Nonetheless, for the purposes that this package was created fixing a time-grid tt at initialization of any GuidProp is helpful in reducing the computational cost of the algorithm. Currently, if sampling on finer grid is needed at any point, then GuidProp object needs to be redefined.","category":"page"},{"location":"manual/guid_prop/#Defining-the-target-law-1","page":"Guided proposals","title":"Defining the target law","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"To define the target law we should make use of another package from the JuliaDiffusionBayes suite: DiffusionDefinition.jl. We can either define the target law using the macro @define_diffusion or—if we can—simply load in a pre-defined processes.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"tip: Running example—Lotka-Volterra model—defining the target law\nusing DiffusionDefinition\nconst DD = DiffusionDefinition\n@load_diffusion LotkaVolterra # for constructing the target law\n\nθ = [2.0/3.0, 4.0/3.0, 1.0, 1.0, 0.2, 0.2]\nP_target = LotkaVolterra(θ...)","category":"page"},{"location":"manual/guid_prop/#Defining-the-auxiliary-law-1","page":"Guided proposals","title":"Defining the auxiliary law","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"When we pass the auxiliary law to GuidProp we pass only the name of a struct that defines it and not the actual instance of it. The object will be initialized internally by GuidProp. For this reason, the following convention MUST be adhered to:","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"the auxiliary law is limited to having the same parameter names as the target law; internally GuidProp cycles through all parameters needed by the auxiliary law and looks for the corresponding entry in the target law and uses values of the corresponding parameters found there. Importantly, the association is done by name\nin addition to parameters the auxiliary law is expected to have the following fields of the type :auxiliary_info:\n:t0\n:T\n:vT","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"Additionally, the field :xT will be defined automatically and (if need be) auto-initialized (but can also be declared explicitly).","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"warning: Warning\nNo other field from :auxiliary_info (apart from explicitly declaring :xT) can be used (i.e. fields :v0 and :x0). This last restriction will probably be relaxed in the near future.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"tip: Running example—Lotka-Volterra model—defining the auxiliary law\n@load_diffusion LotkaVolterraAux","category":"page"},{"location":"manual/guid_prop/#Defining-the-terminal-observation-1","page":"Guided proposals","title":"Defining the terminal observation","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"To define the terminal observation we should make use of another package from the JuliaDiffusionBayes.jl suite: ObservationSchemes.jl.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"tip: Running example—Lotka-Volterra model—defining the observation\nLet's initialize an observation sampled according to a scheme: $ v=X+\\eta,\\quad \\eta\\sim N(0,I). $using ObservationSchemes, StaticArrays\nt, xₜ = 3.0, @SVector [0.5, 0.8]\nobs = LinearGsnObs(t, xₜ; Σ=1e-4*SDiagonal{2,Float64}(I))","category":"page"},{"location":"manual/guid_prop/#Initializing-GuidProp-1","page":"Guided proposals","title":"Initializing GuidProp","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"It is now possible to define GuidProp. We may specify the time-grid, and then, leave the remaining parameters at their defaults. At initialization time a sequence of computations is performed that derive a guiding term for t's lying on a pre-specified time-grid tt, as well as some additional quantities that are needed for computations of the log-likelihoods.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"tip: Running example—Lotka-Volterra model—defining GuidProp\ndt = 0.001\ntt = 0.0:dt:t\nP = GuidProp(tt, P_target, LotkaVolterraAux, obs)","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"note: Note\nIf at any point the parameters change, then the guiding term might need to be re-computed (in fact, this is the centerpiece of the backward filtering part of the forward filtering-backward guiding algorithm). We provide certain utility functions that facilitate these operations. See ... for more details.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"note: Note\nAdditional set of options passed to GuidProp are specified in the field solver_choice, which by default is set to:solver_choice=(\n      solver=Tsit5(),\n      ode_type=:HFc,\n      convert_to_HFc=false,\n      mode=:outofplace,\n      gradients=false,\n      eltype=Float64,\n)The constructor expects it to be a NamedTuple with the respective fields (but it is robust enough to fill-in any missing fields with defaults). The meaning of the fields is as follows:solver is passed to DifferentialEquations.jl to pick an algorithm for solving ODEs that define the guiding term. More about the ODE systems is written in ODE types.\node_type is used to pick between three choices of ODE systems to use: H, F, c system, M, L, μ system and P, ν (and c, but c needs to be added to names). They have the labels: :HFc, MLμ, Pν respectively, which are not case sensitive and currently only HFc is implemented)\nconvert_to_HFc is used only when :MLμ has been chosen to be a solver of ODEs. In that scenario, if convert_to_HFc is set to true, then the terms M, L, μ that the ODE systems solve for will be used to compute the corresponding H, F, c terms (as opposed to using :HFc solver to solve for them)\nmode is an important flag (currently only :outofplace is fully supported) and it is used to tell GuidProp what type of computations are being performed: out-of-place :outofplace, which are based on SVectors from StaticArrays.jl, in-place :inplace, which are based on Vectors or :gpu, which are based on cuArrays.\ngradients is another important flag for telling GuidProp whether gradients with respect to something need to be computed.\neltype ignore this for a moment, we need to figure some things out with this...","category":"page"},{"location":"manual/guid_prop/#Sampling-guided-proposals-1","page":"Guided proposals","title":"Sampling guided proposals","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"Once GuidProp has been initialized, trajectories of guided proposals may be sampled from it.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"GuidedProposals.rand\nGuidedProposals.rand!","category":"page"},{"location":"manual/guid_prop/#Base.rand","page":"Guided proposals","title":"Base.rand","text":"Base.rand(\n    [rng::Random.AbstractRNG], P::GuidProp, y1=zero(P); f=DD.__DEFAULT_F\n)\n\nSample a trajectory of a guided proposal P started from y1. Initialize containers in the background and compute the functional f at the time of sampling.\n\n\n\n\n\nBase.rand(\n    [rng::Random.AbstractRNG],\n    PP::AbstractArray{<:GuidProp}, y1=zero(PP[1]); f=DD.__DEFAULT_F\n)\n\nSample a trajectory started from y1, defined for multiple guided proposals PP that correspond to consecutive intervals. Initialize containers in the background and compute the functionals f (one for each interval) at the time of sampling.\n\n\n\n\n\n","category":"function"},{"location":"manual/guid_prop/#Random.rand!","page":"Guided proposals","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG],\n    P::GuidProp,\n    X, W, y1=zero(P);\n    f=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X and W to save the results. Compute the functional f at the time of sampling.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG],\n    P::GuidProp,\n    X°, W°, W, ρ, y1=zero(P);\n    f=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X° and W° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter ρ and a previously sampled Wiener noise W. Compute the functional f at the time of sampling.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG]\n    P::GuidProp,\n    X, W, v::Val{:ll}, y1=zero(P);\n    Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X and W to save the results. Compute log-likelihood (only path contribution) along the way.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG]\n    P::GuidProp,\n    X°, W°, W, ρ, v::Val{:ll}, y1=zero(P);\n    Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X° and W° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter ρ and a previously sampled Wiener noise W. Compute log-likelihood (only path contribution) along the way.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX, WW, y1=zero(PP[1]);\n    f=DD.__DEFAULT_F, f_out=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX and WW to save the results. Compute the functionals f (one for each interval) at the time of sampling and store the results in f_out.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX°, WW°, WW, ρρ, y1=zero(PP[1]);\n    f=DD.__DEFAULT_F, f_out=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX° and WW° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter ρ (one for the entire interval) and a previously sampled Wiener noise WW. Compute the functionals f (one for each interval) at the time of sampling and store the results in f_out.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX, WW, v::Val{:ll}, y1=zero(PP[1]);\n    Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX° and WW° to save the results. Compute log-likelihood (path contribution AND end-points contribution) along the way.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX°, WW°, WW, ρρ, v::Val{:ll}, y1=zero(PP[1]);\n    Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX° and WW° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameters ρ (one for the entire interval) and a previously sampled Wiener noise WW. Compute log-likelihood (path contribution AND end-points contribution) along the way.\n\n\n\n\n\n","category":"function"},{"location":"manual/guid_prop/#Sampling-a-single-trajectory-1","page":"Guided proposals","title":"Sampling a single trajectory","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"To sample a single trajectory and initialize appropriate containers in the background call rand. Note that rand returns two containers (one for the underlying process: X and another for the Wiener process: W) and a flag for sampling Wiener process Wnr. X, W and Wnr may then be used with rand! for re-sampling without having to allocate any additional memory.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"tip: Running example—Lotka-Volterra model—sampling a single path\nx0 = @SVector [2.0, 0.25]\nX, W, Wnr = rand(P, x0)\n\nplot(X, Val(:x_vs_y))\nscatter!([y1[1]],[y1[2]], markersize=8, label=\"starting point\")\nscatter!([vT[1]],[vT[2]], marker=:diamond, markersize=8, label=\"conditioned-on point\")(Image: lotka_volterra_single_gp)","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"Alternatively, you may choose to be more explicit: initialize the containers yourself and then call rand!. Note however that if the diffusion's state space is not RR^d you might need to keep re-sampling to make sure the conditions are satisfied.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"# initialize containers\nX, W = trajectory(P)\n# sample the process\nsuccess = false\nwhile !success\n    success, _ = rand!(P, X, W, x0; Wnr=Wiener())\nend","category":"page"},{"location":"manual/guid_prop/#single_obs_multiple_trajectories-1","page":"Guided proposals","title":"Sampling multiple trajectories","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"Of course, sampling a single trajectory of a guided proposal is usually not the end-goal. We are instead interested in sampling from the target law. To this end we need to not only sample paths, but also compute their log-likelihoods. This can be done in three ways.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"First, you may simply call loglikhd after the path has been sampled to compute the log-likelihood for it\nSecond, just as in DiffusionDefinition.jl rand and rand! accept a named argument f which computes path functionals when sampling. A function that computes the log-likelihood may be passed there.\nThird—a preferable method—you may call versions of rand! that have optimized versions of log-likelihood computations implemented for them.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"success, ll = rand!(P, X, W, Val(:ll), x0; Wnr=Wiener())","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"warning: Warning\nll returned by rand! is not exactly log-likelihood for the path XX and one needs to be careful what is the meaning of it. Consult the section on log-likelihoods to find out more.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"With these functions we may very easily perform smoothing to obtain samples under the target law:","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"function simple_smoothing(P, y1)\n\tX, W, Wnr = rand(P, y1)\n\tX°, W° = trajectory(P)\n\n\tll = loglikhd(P, X)\n\tpaths = []\n\n\tfor i in 1:10^4\n\t\t_, ll° = rand!(P, X°, W°, Val(:ll), y1; Wnr=Wnr)\n\t\tif rand() < exp(ll°-ll)\n\t\t\tX, W, X°, W° = X°, W°, X, W\n\t\t\tll = ll°\n\t\tend\n\t\ti % 400 == 0 && append!(paths, [deepcopy(X)])\n\tend\n\tpaths\nend\npaths = simple_smoothing(P, y1)","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"which results in","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"using Plots, Colors\ncm = colormap(\"RdBu\")\nkwargs = (alpha=0.3, label=\"\")\np = plot(paths[1], Val(:x_vs_y); color=cm[1], kwargs...)\nfor (i,x) in enumerate(paths[2:end])\n\tplot!(p, x, Val(:x_vs_y); color=cm[4*i], kwargs...)\nend\ndisplay(p)","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"(Image: simple_smoothing)","category":"page"},{"location":"manual/guid_prop/#Preconditioned-Crank–Nicolson-scheme-1","page":"Guided proposals","title":"Preconditioned Crank–Nicolson scheme","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"To use the Crank–Nicolson scheme pass additional parameters W (the previously accepted Wiener noise) and ρ (the memory parameter of the preconditioned Crank–Nicolson scheme to a rand! function):","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"X°, W° = trajectory(P)\nρ = 0.7\nsuccess, ll° = rand!(P, X°, W°, W, ρ, Val(:ll), y1; Wnr=Wnr)","category":"page"},{"location":"manual/bffg/#Backward-filtering-forward-guiding-algorithm-1","page":"BFFG algorithm","title":"Backward filtering-forward guiding algorithm","text":"","category":"section"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"Backward filtering-forward guiding algorithm is a computational framework for sampling conditioned diffusions, it has been described in detail in this paper and it is what happens behind the scenes of GuidedProposals.jl.","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"Briefly, it comprises of two passes, that—if repeated many times—may result in a smoothing or inference algorithms. The two steps are:","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"backward filtering &\nforward guiding.","category":"page"},{"location":"manual/bffg/#Backward-filtering-1","page":"BFFG algorithm","title":"Backward filtering","text":"","category":"section"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"Backward filtering is a technical term for propagating the information about the observations (that lie in the future) back into the parts of the interval that precede them (and on which the diffusion is defined). It is simply the process of computing the guiding term. It is done implicitly every time GuidProp is instantiated. Additionally, after parameters change it may also be done explicitly by calling recompute_guiding_term! or its alias","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"backward_filter!","category":"page"},{"location":"manual/bffg/#GuidedProposals.backward_filter!","page":"BFFG algorithm","title":"GuidedProposals.backward_filter!","text":"alias to recompute_guiding_term!\n\n\n\n\n\n","category":"function"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"see the section on reparameterizations for more details.","category":"page"},{"location":"manual/bffg/#Forward-guiding-1","page":"BFFG algorithm","title":"Forward guiding","text":"","category":"section"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"Forward guiding is a technical term for sampling guiding proposals. It is encapsulated by various rand, rand! and solve_and_ll! routines. You may also call","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"GuidedProposals.forward_guide!","category":"page"},{"location":"manual/bffg/#GuidedProposals.forward_guide!","page":"BFFG algorithm","title":"GuidedProposals.forward_guide!","text":"alias to rand!\n\n\n\n\n\n","category":"function"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"See sections Defining guided proposals and Guided proposals with multiple observations for more details about sampling.","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"tip: Tip\nCheck-out the how-to guides and tutorials on smoothing and inference to see the BFFG algorithm in action.","category":"page"},{"location":"#GuidedProposals.jl-1","page":"Home","title":"GuidedProposals.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Efficient and user-friendly guided proposals in Julia. Introduced in M Schauer, F van der Meulen and H van Zanten Guided proposals for simulating multi-dimensional diffusion bridges (2017) [arXiv].","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Provides methods for efficient sampling of conditioned diffusions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Depending on your intended use of this package you might choose to start at different places:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a quick overview of GuidedProposals.jl's main functionality see Get started.\nFor a systematic introduction to all functionality introduced in this package see the Manual\nFor a didactic introduction to problems that can be solved using GuidedProposals.jl see the Tutorials\nIf you have a problem that you think can be addressed with this package, then check out the How-to guides to see if the answer is already there.","category":"page"}]
}
