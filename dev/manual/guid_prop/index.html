<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guided proposals · GuidedProposals.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="GuidedProposals.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">GuidedProposals.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_started/overview/">Get started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">User manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Guided proposals</a><ul class="internal"><li><a class="tocitem" href="#Defining-the-target-law"><span>Defining the target law</span></a></li><li><a class="tocitem" href="#Defining-the-auxiliary-law"><span>Defining the auxiliary law</span></a></li><li><a class="tocitem" href="#Defining-the-terminal-observation"><span>Defining the terminal observation</span></a></li><li><a class="tocitem" href="#Initializing-GuidProp"><span>Initializing GuidProp</span></a></li><li class="toplevel"><a class="tocitem" href="#Sampling-guided-proposals"><span>Sampling guided proposals</span></a></li><li><a class="tocitem" href="#Sampling-a-single-trajectory"><span>Sampling a single trajectory</span></a></li><li><a class="tocitem" href="#single_obs_multiple_trajectories"><span>Sampling multiple trajectories</span></a></li><li><a class="tocitem" href="#Preconditioned-Crank–Nicolson-scheme"><span>Preconditioned Crank–Nicolson scheme</span></a></li></ul></li><li><a class="tocitem" href="../multiple_obs/">Multiple observations</a></li><li><a class="tocitem" href="../log_likelihood/">Log-likelihoods</a></li><li><a class="tocitem" href="../reparameterizations/">Reparameterizations</a></li><li><a class="tocitem" href="../bffg/">BFFG algorithm</a></li><li><a class="tocitem" href="../path_functionals/">Computing path functionals</a></li><li><a class="tocitem" href="../ode_type/">(TODO) ODE systems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to...</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../how_to_guides/sample_bridges/">(TODO) Sample diffusion bridges</a></li><li><a class="tocitem" href="../../how_to_guides/first_passage_time/">(TODO) Sample diffusions in first-passage time setting</a></li><li><a class="tocitem" href="../../how_to_guides/smoothing/">...smooth trajectories</a></li><li><a class="tocitem" href="../../how_to_guides/blocking/">...do blocking</a></li><li><a class="tocitem" href="../../how_to_guides/parameter_inference/">...infer parameters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/in_place_vs_out_of_place/">(TODO) Understanding in-place vs out-of-place</a></li><li><a class="tocitem" href="../../tutorials/smoothing/">Smoothing trajectories of the partially observed FitzHugh–Nagumo diffusion</a></li><li><a class="tocitem" href="../../tutorials/blocking/">Setting up a blocking scheme for a simple smoothing problem</a></li><li><a class="tocitem" href="../../tutorials/parameter_inference/">Parameter inference</a></li></ul></li><li><a class="tocitem" href="../../module_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User manual</a></li><li class="is-active"><a href>Guided proposals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guided proposals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl/blob/master/docs/src/manual/guid_prop.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="manual_start"><a class="docs-heading-anchor" href="#manual_start">Defining guided proposals</a><a id="manual_start-1"></a><a class="docs-heading-anchor-permalink" href="#manual_start" title="Permalink"></a></h1><hr/><p>The main object used to define guided proposals is</p><article class="docstring"><header><a class="docstring-binding" id="GuidedProposals.GuidProp" href="#GuidedProposals.GuidProp"><code>GuidedProposals.GuidProp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GuidProp{
        K,DP,DW,SS,R,R2,O,S,T
        } &lt;: DiffusionDefinition.DiffusionProcess{K,DP,DW,SS}
    P_target::R
    P_aux::R2
    obs::O
    guiding_term_solver::S
end</code></pre><p>Struct defining <code>guided proposals</code> of <em>M Schauer, F van der Meulen and H van Zanten</em>. See <em>Mider M, Schauer M and van der Meulen F</em> &quot;Continuous-discrete smoothing of diffusions&quot; (2020) for a comprehensive overview of the mathematics behind this object. It computes and stores the guiding term <code>∇logρ</code> and allows for simulation of guided proposals and computation of their likelihood.</p><pre><code class="language-none">GuidProp(
        tt,
        P_target::R,
        P_aux_type::Type{TR2},
        obs::O,
        solver_choice=(
            solver=Tsit5(),
            ode_type=:HFc,
            convert_to_HFc=false,
            mode=:inplace,
            gradients=false,
            eltype=Float64,
        ),
        next_guided_prop=nothing,
    ) where {
        R&lt;:DD.DiffusionProcess,
        TR2&lt;:DD.DiffusionProcess,
        O&lt;:OBS.Observation
    }</code></pre><p>Default constructor. <code>P_target</code> and <code>P_aux</code> are the target and the type of the auxiliary diffusion laws respectively, <code>tt</code> is the time-grid on which <code>∇logρ</code> needs to be computed. <code>obs</code> is the terminal observation (and the only one on the interval (<code>tt[1]</code>, <code>tt[end]</code>]). <code>solver_choice</code> specifies the type of ODE solver that is to be used for computations of <code>∇logρ</code>     ( it is a <code>NamedTuple</code>, where <code>solver</code> specifies the algorithm for solving     ODEs (see the documentation of DifferentialEquations.jl for possible     choices), <code>ode_type</code> picks the ODE system (between :HFc, :MLμ and :Pν),     <code>convert_to_HFc</code> indicates whether to translate the results of M,L,μ solver     to H,F,c objects, <code>mode</code> is a flag indicating the way in which data is being     handled:     - <code>:inplace</code>: uses regular arrays to store the data (requires functions                   B!, β!, σ! and a! to be defined)     - <code>:outofplace</code>: operates on static arrays     - <code>:gpu</code>: operates on GPU arrays [TODO not implemented yet]     <code>gradients</code> is a flag indicating whether automatic differentiation is to     be employed and <code>eltype</code> indicates the data-type of each container&#39;s     member. ) Finally, <code>next_guided_prop</code> is the guided proposal for the subsequent inter-observation interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl/blob/ed6a12d0862b20db02e1b3c5811035905e0b0194/src/guided_proposals.jl#LL7-L63">source</a></section></article><p>The main role of this object is to facilitate sampling of diffusion paths from some <code>target</code> diffusion law by:</p><ul><li>drawing from a <code>proposal</code> diffusion law &amp;</li><li>computing an importance sampling weight</li></ul><p>Performing these two steps in a setting of importance sampling or mcmc sampling makes it possible to draw sample-paths from the <code>target</code> law.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>From the conceptual point of view, the target and auxiliary laws, as well as the terminal observations are all required to define a guided proposal. However, conceptually, guided proposals are defined as continuous-time processes, and thus, it should be possible to look-up the value of any sampled trajectory at any time <span>$t\in[0,T]$</span>. <code>tt</code>— the time grid on which the path is to be revealed—is thus conceptually superfluous at the time of initialization. Nonetheless, for the purposes that this package was created fixing a time-grid <code>tt</code> at initialization of any <code>GuidProp</code> is helpful in reducing the computational cost of the algorithm. Currently, if sampling on finer grid is needed at any point, then <code>GuidProp</code> object needs to be redefined.</p></div></div><h2 id="Defining-the-target-law"><a class="docs-heading-anchor" href="#Defining-the-target-law">Defining the target law</a><a id="Defining-the-target-law-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-target-law" title="Permalink"></a></h2><hr/><p>To define the target law we should make use of another package from the <a href="https://github.com/JuliaDiffusionBayes/">JuliaDiffusionBayes</a> suite: <a href="https://github.com/JuliaDiffusionBayes/DiffusionDefinition.jl">DiffusionDefinition.jl</a>. We can either define the target law using the macro <code>@define_diffusion</code> or—if we can—simply load in a pre-defined processes.</p><div class="admonition is-success"><header class="admonition-header">Running example—Lotka-Volterra model—defining the target law</header><div class="admonition-body"><pre><code class="language-julia">using DiffusionDefinition
const DD = DiffusionDefinition
@load_diffusion LotkaVolterra # for constructing the target law

θ = [2.0/3.0, 4.0/3.0, 1.0, 1.0, 0.2, 0.2]
P_target = LotkaVolterra(θ...)</code></pre></div></div><h2 id="Defining-the-auxiliary-law"><a class="docs-heading-anchor" href="#Defining-the-auxiliary-law">Defining the auxiliary law</a><a id="Defining-the-auxiliary-law-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-auxiliary-law" title="Permalink"></a></h2><hr/><p>When we pass the auxiliary law to <code>GuidProp</code> we pass only the name of a struct that defines it and not the actual instance of it. The object will be initialized internally by <code>GuidProp</code>. For this reason, the following convention <strong>MUST</strong> be adhered to:</p><ul><li>the auxiliary law is limited to having the same parameter names as the target law; internally <code>GuidProp</code> cycles through all parameters needed by the auxiliary law and looks for the corresponding entry in the target law and uses values of the corresponding parameters found there. Importantly, the association is done <strong>by name</strong></li><li>in addition to parameters the auxiliary law is expected to have the following fields of the type <code>:auxiliary_info</code>:<ul><li><code>:t0</code></li><li><code>:T</code></li><li><code>:vT</code></li></ul></li></ul><p>Additionally, the field <code>:xT</code> will be defined automatically and (if need be) auto-initialized (but can also be declared explicitly).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>No other field from <code>:auxiliary_info</code> (apart from explicitly declaring <code>:xT</code>) can be used (i.e. fields <code>:v0</code> and <code>:x0</code>). This last restriction will probably be relaxed in the near future.</p></div></div><div class="admonition is-success"><header class="admonition-header">Running example—Lotka-Volterra model—defining the auxiliary law</header><div class="admonition-body"><pre><code class="language-julia">@load_diffusion LotkaVolterraAux</code></pre></div></div><h2 id="Defining-the-terminal-observation"><a class="docs-heading-anchor" href="#Defining-the-terminal-observation">Defining the terminal observation</a><a id="Defining-the-terminal-observation-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-terminal-observation" title="Permalink"></a></h2><hr/><p>To define the terminal observation we should make use of another package from the <a href="https://github.com/JuliaDiffusionBayes/JuliaDiffusionBayes.jl">JuliaDiffusionBayes.jl</a> suite: <a href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl">ObservationSchemes.jl</a>.</p><div class="admonition is-success"><header class="admonition-header">Running example—Lotka-Volterra model—defining the observation</header><div class="admonition-body"><p>Let&#39;s initialize an observation sampled according to a scheme: $ v=X+\eta,\quad \eta\sim N(0,I). $</p><pre><code class="language-julia">using ObservationSchemes, StaticArrays
t, xₜ = 3.0, @SVector [0.5, 0.8]
obs = LinearGsnObs(t, xₜ; Σ=1e-4*SDiagonal{2,Float64}(I))</code></pre></div></div><h2 id="Initializing-GuidProp"><a class="docs-heading-anchor" href="#Initializing-GuidProp">Initializing GuidProp</a><a id="Initializing-GuidProp-1"></a><a class="docs-heading-anchor-permalink" href="#Initializing-GuidProp" title="Permalink"></a></h2><hr/><p>It is now possible to define <code>GuidProp</code>. We may specify the time-grid, and then, leave the remaining parameters at their defaults. At initialization time a sequence of computations is performed that derive a <code>guiding term</code> for <code>t</code>&#39;s lying on a pre-specified time-grid <code>tt</code>, as well as some additional quantities that are needed for computations of the <code>log-likelihoods</code>.</p><div class="admonition is-success"><header class="admonition-header">Running example—Lotka-Volterra model—defining GuidProp</header><div class="admonition-body"><pre><code class="language-julia">dt = 0.001
tt = 0.0:dt:t
P = GuidProp(tt, P_target, LotkaVolterraAux, obs)</code></pre></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If at any point the parameters change, then the <code>guiding term</code> might need to be re-computed (in fact, this is the centerpiece of the <code>backward filtering</code> part of the <code>forward filtering-backward guiding</code> algorithm). We provide certain utility functions that facilitate these operations. See ... for more details.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Additional set of options passed to <code>GuidProp</code> are specified in the field <code>solver_choice</code>, which by default is set to:</p><pre><code class="language-julia">solver_choice=(
      solver=Tsit5(),
      ode_type=:HFc,
      convert_to_HFc=false,
      mode=:outofplace,
      gradients=false,
      eltype=Float64,
)</code></pre><p>The constructor expects it to be a NamedTuple with the respective fields (but it is robust enough to fill-in any missing fields with defaults). The meaning of the fields is as follows:</p><ul><li><code>solver</code> is passed to <code>DifferentialEquations.jl</code> to pick an algorithm for solving ODEs that define the guiding term. More about the ODE systems is written in <a href="../ode_type/#ode_types">ODE types</a>.</li><li><code>ode_type</code> is used to pick between three choices of ODE systems to use: <code>H</code>, <code>F</code>, <code>c</code> system, <code>M</code>, <code>L</code>, <code>μ</code> system and <code>P</code>, <code>ν</code> (and <code>c</code>, but <code>c</code> needs to be added to names). They have the labels: <code>:HFc</code>, <code>MLμ</code>, <code>Pν</code> respectively, which are not case sensitive and currently only <code>HFc</code> is implemented)</li><li><code>convert_to_HFc</code> is used only when <code>:MLμ</code> has been chosen to be a solver of ODEs. In that scenario, if <code>convert_to_HFc</code> is set to <code>true</code>, then the terms <code>M</code>, <code>L</code>, <code>μ</code> that the ODE systems solve for will be used to compute the corresponding <code>H</code>, <code>F</code>, <code>c</code> terms (as opposed to using <code>:HFc</code> solver to solve for them)</li><li><code>mode</code> is an important flag (currently only <code>:outofplace</code> is fully supported) and it is used to tell <code>GuidProp</code> what type of computations are being performed: out-of-place <code>:outofplace</code>, which are based on <code>SVector</code>s from <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a>, in-place <code>:inplace</code>, which are based on <code>Vector</code>s or <code>:gpu</code>, which are based on <code>cuArray</code>s.</li><li><code>gradients</code> is another important flag for telling <code>GuidProp</code> whether gradients with respect to something need to be computed.</li><li><code>eltype</code> ignore this for a moment, we need to figure some things out with this...</li></ul></div></div><h1 id="Sampling-guided-proposals"><a class="docs-heading-anchor" href="#Sampling-guided-proposals">Sampling guided proposals</a><a id="Sampling-guided-proposals-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-guided-proposals" title="Permalink"></a></h1><hr/><p>Once <code>GuidProp</code> has been initialized, trajectories of guided proposals may be sampled from it.</p><article class="docstring"><header><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.rand(
    [rng::Random.AbstractRNG], P::GuidProp, y1=zero(P); f=DD.__DEFAULT_F
)</code></pre><p>Sample a trajectory of a guided proposal <code>P</code> started from <code>y1</code>. Initialize containers in the background and compute the functional <code>f</code> at the time of sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl/blob/ed6a12d0862b20db02e1b3c5811035905e0b0194/src/sampling.jl#LL49-L57">source</a></section><section><div><pre><code class="language-julia">Base.rand(
    [rng::Random.AbstractRNG],
    PP::AbstractArray{&lt;:GuidProp}, y1=zero(PP[1]); f=DD.__DEFAULT_F
)</code></pre><p>Sample a trajectory started from <code>y1</code>, defined for multiple guided proposals <code>PP</code> that correspond to consecutive intervals. Initialize containers in the background and compute the functionals <code>f</code> (one for each interval) at the time of sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl/blob/ed6a12d0862b20db02e1b3c5811035905e0b0194/src/sampling.jl#LL337-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.rand!" href="#Random.rand!"><code>Random.rand!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Random.rand!(
    [rng::Random.AbstractRNG],
    P::GuidProp,
    X, W, y1=zero(P);
    f=DD.__DEFAULT_F, Wnr=Wiener()
)</code></pre><p>Sample a trajectory of a guided proposal <code>P</code> started from <code>y1</code>. Use containers <code>X</code> and <code>W</code> to save the results. Compute the functional <code>f</code> at the time of sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl/blob/ed6a12d0862b20db02e1b3c5811035905e0b0194/src/sampling.jl#LL102-L113">source</a></section><section><div><pre><code class="language-julia">Random.rand!(
    [rng::Random.AbstractRNG],
    P::GuidProp,
    X°, W°, W, ρ, y1=zero(P);
    f=DD.__DEFAULT_F, Wnr=Wiener()
)</code></pre><p>Sample a trajectory of a guided proposal <code>P</code> started from <code>y1</code>. Use containers <code>X°</code> and <code>W°</code> to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter <code>ρ</code> and a previously sampled Wiener noise <code>W</code>. Compute the functional <code>f</code> at the time of sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl/blob/ed6a12d0862b20db02e1b3c5811035905e0b0194/src/sampling.jl#LL159-L171">source</a></section><section><div><pre><code class="language-julia">Random.rand!(
    [rng::Random.AbstractRNG]
    P::GuidProp,
    X, W, v::Val{:ll}, y1=zero(P);
    Wnr=Wiener()
)</code></pre><p>Sample a trajectory of a guided proposal <code>P</code> started from <code>y1</code>. Use containers <code>X</code> and <code>W</code> to save the results. Compute log-likelihood (only path contribution) along the way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl/blob/ed6a12d0862b20db02e1b3c5811035905e0b0194/src/sampling.jl#LL218-L229">source</a></section><section><div><pre><code class="language-julia">Random.rand!(
    [rng::Random.AbstractRNG]
    P::GuidProp,
    X°, W°, W, ρ, v::Val{:ll}, y1=zero(P);
    Wnr=Wiener()
)</code></pre><p>Sample a trajectory of a guided proposal <code>P</code> started from <code>y1</code>. Use containers <code>X°</code> and <code>W°</code> to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter <code>ρ</code> and a previously sampled Wiener noise <code>W</code>. Compute log-likelihood (only path contribution) along the way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl/blob/ed6a12d0862b20db02e1b3c5811035905e0b0194/src/sampling.jl#LL275-L287">source</a></section><section><div><pre><code class="language-julia">Random.rand!(
    [rng::Random.AbstractRNG]
    PP::AbstractArray{&lt;:GuidProp},
    XX, WW, y1=zero(PP[1]);
    f=DD.__DEFAULT_F, f_out=DD.__DEFAULT_F, Wnr=Wiener()
)</code></pre><p>Sample a trajectory started from <code>y1</code> over multiple intervals for guided proposals <code>PP</code> that correspond to consecutive intervals. Use containers <code>XX</code> and <code>WW</code> to save the results. Compute the functionals <code>f</code> (one for each interval) at the time of sampling and store the results in <code>f_out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl/blob/ed6a12d0862b20db02e1b3c5811035905e0b0194/src/sampling.jl#LL379-L391">source</a></section><section><div><pre><code class="language-julia">Random.rand!(
    [rng::Random.AbstractRNG]
    PP::AbstractArray{&lt;:GuidProp},
    XX°, WW°, WW, ρρ, y1=zero(PP[1]);
    f=DD.__DEFAULT_F, f_out=DD.__DEFAULT_F, Wnr=Wiener()
)</code></pre><p>Sample a trajectory started from <code>y1</code> over multiple intervals for guided proposals <code>PP</code> that correspond to consecutive intervals. Use containers <code>XX°</code> and <code>WW°</code> to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter <code>ρ</code> (one for the entire interval) and a previously sampled Wiener noise <code>WW</code>. Compute the functionals <code>f</code> (one for each interval) at the time of sampling and store the results in <code>f_out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl/blob/ed6a12d0862b20db02e1b3c5811035905e0b0194/src/sampling.jl#LL444-L458">source</a></section><section><div><pre><code class="language-julia">Random.rand!(
    [rng::Random.AbstractRNG]
    PP::AbstractArray{&lt;:GuidProp},
    XX, WW, v::Val{:ll}, y1=zero(PP[1]);
    Wnr=Wiener()
)</code></pre><p>Sample a trajectory started from <code>y1</code> over multiple intervals for guided proposals <code>PP</code> that correspond to consecutive intervals. Use containers <code>XX°</code> and <code>WW°</code> to save the results. Compute log-likelihood (path contribution AND end-points contribution) along the way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl/blob/ed6a12d0862b20db02e1b3c5811035905e0b0194/src/sampling.jl#LL511-L523">source</a></section><section><div><pre><code class="language-julia">Random.rand!(
    [rng::Random.AbstractRNG]
    PP::AbstractArray{&lt;:GuidProp},
    XX°, WW°, WW, ρρ, v::Val{:ll}, y1=zero(PP[1]);
    Wnr=Wiener()
)</code></pre><p>Sample a trajectory started from <code>y1</code> over multiple intervals for guided proposals <code>PP</code> that correspond to consecutive intervals. Use containers <code>XX°</code> and <code>WW°</code> to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameters <code>ρ</code> (one for the entire interval) and a previously sampled Wiener noise <code>WW</code>. Compute log-likelihood (path contribution AND end-points contribution) along the way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl/blob/ed6a12d0862b20db02e1b3c5811035905e0b0194/src/sampling.jl#LL577-L591">source</a></section></article><h2 id="Sampling-a-single-trajectory"><a class="docs-heading-anchor" href="#Sampling-a-single-trajectory">Sampling a single trajectory</a><a id="Sampling-a-single-trajectory-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-a-single-trajectory" title="Permalink"></a></h2><hr/><p>To sample a single trajectory and initialize appropriate containers in the background call <code>rand</code>. Note that <code>rand</code> returns two containers (one for the underlying process: <code>X</code> and another for the Wiener process: <code>W</code>) and a flag for sampling Wiener process <code>Wnr</code>. <code>X</code>, <code>W</code> and <code>Wnr</code> may then be used with <code>rand!</code> for re-sampling without having to allocate any additional memory.</p><div class="admonition is-success"><header class="admonition-header">Running example—Lotka-Volterra model—sampling a single path</header><div class="admonition-body"><pre><code class="language-julia">x0 = @SVector [2.0, 0.25]
X, W, Wnr = rand(P, x0)

plot(X, Val(:x_vs_y))
scatter!([y1[1]],[y1[2]], markersize=8, label=&quot;starting point&quot;)
scatter!([vT[1]],[vT[2]], marker=:diamond, markersize=8, label=&quot;conditioned-on point&quot;)</code></pre><p><img src="../../assets/manual/guid_prop_define/lotka_volterra_single_gp.png" alt="lotka_volterra_single_gp"/></p></div></div><p>Alternatively, you may choose to be more explicit: initialize the containers yourself and then call <code>rand!</code>. Note however that if the diffusion&#39;s state space is not <span>$\RR^d$</span> you might need to keep re-sampling to make sure the conditions are satisfied.</p><pre><code class="language-julia"># initialize containers
X, W = trajectory(P)
# sample the process
success = false
while !success
    success, _ = rand!(P, X, W, x0; Wnr=Wiener())
end</code></pre><h2 id="single_obs_multiple_trajectories"><a class="docs-heading-anchor" href="#single_obs_multiple_trajectories">Sampling multiple trajectories</a><a id="single_obs_multiple_trajectories-1"></a><a class="docs-heading-anchor-permalink" href="#single_obs_multiple_trajectories" title="Permalink"></a></h2><hr/><p>Of course, sampling a single trajectory of a guided proposal is usually not the end-goal. We are instead interested in sampling from the target law. To this end we need to not only sample paths, but also compute their log-likelihoods. This can be done in three ways.</p><ol><li>First, you may simply call <code>loglikhd</code> after the path has been sampled to compute the log-likelihood for it</li><li>Second, just as in <a href="https://juliadiffusionbayes.github.io/DiffusionDefinition.jl/dev/manual/functionals_of_paths/">DiffusionDefinition.jl</a> <code>rand</code> and <code>rand!</code> accept a named argument <code>f</code> which computes path functionals when sampling. A function that computes the log-likelihood may be passed there.</li><li>Third—a preferable method—you may call versions of <code>rand!</code> that have optimized versions of log-likelihood computations implemented for them.</li></ol><pre><code class="language-julia">success, ll = rand!(P, X, W, Val(:ll), x0; Wnr=Wiener())</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>ll</code> returned by <code>rand!</code> is not exactly log-likelihood for the path <code>XX</code> and one needs to be careful what is the meaning of it. Consult the <a href="../log_likelihood/#log_likelihood_computations">section on log-likelihoods</a> to find out more.</p></div></div><p>With these functions we may very easily perform smoothing to obtain samples under the target law:</p><pre><code class="language-julia">function simple_smoothing(P, y1)
	X, W, Wnr = rand(P, y1)
	X°, W° = trajectory(P)

	ll = loglikhd(P, X)
	paths = []

	for i in 1:10^4
		_, ll° = rand!(P, X°, W°, Val(:ll), y1; Wnr=Wnr)
		if rand() &lt; exp(ll°-ll)
			X, W, X°, W° = X°, W°, X, W
			ll = ll°
		end
		i % 400 == 0 &amp;&amp; append!(paths, [deepcopy(X)])
	end
	paths
end
paths = simple_smoothing(P, y1)</code></pre><p>which results in</p><pre><code class="language-julia">using Plots, Colors
cm = colormap(&quot;RdBu&quot;)
kwargs = (alpha=0.3, label=&quot;&quot;)
p = plot(paths[1], Val(:x_vs_y); color=cm[1], kwargs...)
for (i,x) in enumerate(paths[2:end])
	plot!(p, x, Val(:x_vs_y); color=cm[4*i], kwargs...)
end
display(p)</code></pre><p><img src="../../assets/manual/guid_prop_define/lotka_volterra_simple_smoothing.png" alt="simple_smoothing"/></p><h2 id="Preconditioned-Crank–Nicolson-scheme"><a class="docs-heading-anchor" href="#Preconditioned-Crank–Nicolson-scheme">Preconditioned Crank–Nicolson scheme</a><a id="Preconditioned-Crank–Nicolson-scheme-1"></a><a class="docs-heading-anchor-permalink" href="#Preconditioned-Crank–Nicolson-scheme" title="Permalink"></a></h2><hr/><p>To use the Crank–Nicolson scheme pass additional parameters <code>W</code> (the previously accepted Wiener noise) and <code>ρ</code> (the memory parameter of the preconditioned Crank–Nicolson scheme to a <code>rand!</code> function):</p><pre><code class="language-julia">X°, W° = trajectory(P)
ρ = 0.7
success, ll° = rand!(P, X°, W°, W, ρ, Val(:ll), y1; Wnr=Wnr)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../get_started/overview/">« Get started</a><a class="docs-footer-nextpage" href="../multiple_obs/">Multiple observations »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 5 July 2020 09:38">Sunday 5 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
