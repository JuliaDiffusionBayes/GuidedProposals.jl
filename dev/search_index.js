var documenterSearchIndex = {"docs":
[{"location":"module_index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [GuidedProposals]","category":"page"},{"location":"module_index/#GuidedProposals.F-Tuple{GuidProp,Any}","page":"Index","title":"GuidedProposals.F","text":"F(P::GuidProp, i)\n\nReturn saved vector Fi.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.F-Tuple{GuidedProposals.HFcSolver,Integer}","page":"Index","title":"GuidedProposals.F","text":"F(s::HFcSolver, i::Integer)\n\nReturn saved vector Fi.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.H-Tuple{GuidProp,Any}","page":"Index","title":"GuidedProposals.H","text":"H(P::GuidProp, i)\n\nReturn saved matrix Hi.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.H-Tuple{GuidedProposals.HFcSolver,Integer}","page":"Index","title":"GuidedProposals.H","text":"H(s::HFcSolver, i::Integer)\n\nReturn saved matrix Hi.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.build_guid_prop-Tuple{AbstractArray,NamedTuple,Array{T,1} where T,Any}","page":"Index","title":"GuidedProposals.build_guid_prop","text":"build_guid_prop(\n    aux_laws::AbstractArray, recording::NamedTuple, tts::Vector, args\n)\n\nSame as a version with ::Type{AuxLaw}, but aux_laws is a list of auxiliary laws that correspond to each inter-observation interval.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.build_guid_prop-Union{Tuple{AuxLaw}, Tuple{Type{AuxLaw},NamedTuple,Array{T,1} where T,Vararg{Any,N} where N}} where AuxLaw<:DiffusionDefinition.DiffusionProcess","page":"Index","title":"GuidedProposals.build_guid_prop","text":"build_guid_prop(\n    ::Type{AuxLaw}, recording::NamedTuple, tts::Vector, args...\n) where {AuxLaw <: DD.DiffusionProcess}\n\nInitialize multiple instances of GuidProp corresponding to guided proposals for observations stored in recording. The time grids for each inter-observation interval is given in tts and AuxLaw is the auxiliary law for creating guided proposals. args... are passed to each constructor of GuidProp.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.c-Tuple{GuidProp,Any}","page":"Index","title":"GuidedProposals.c","text":"c(P::GuidProp, i)\n\nReturn saved scalar ci.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.c-Tuple{GuidedProposals.HFcSolver,Integer}","page":"Index","title":"GuidedProposals.c","text":"c(s::HFcSolver, i::Integer)\n\nReturn saved scalar ci.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.loglikhd_obs-Tuple{GuidProp,Any}","page":"Index","title":"GuidedProposals.loglikhd_obs","text":"loglikhd_obs(P::GuidProp, x0)\n\nCompute the contribution of end-points to the log-likelihood function, i.e.: logrho(tx).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.recompute_guiding_term!","page":"Index","title":"GuidedProposals.recompute_guiding_term!","text":"recompute_guiding_term!(P::GuidProp, next_guided_prop=nothing)\n\nRecompute the guiding term (most often used after update of parameters or change of an observation). next_guided_prop is the guided proposal law from the subsequent interval\n\n\n\n\n\n","category":"function"},{"location":"module_index/#GuidedProposals.AbstractGuidingTermSolver","page":"Index","title":"GuidedProposals.AbstractGuidingTermSolver","text":"AbstractGuidingTermSolver{Tmode}\n\nSupertype for ODE solvers (solving H,F,c system or M,L,μ system or P,ν system). Tmode is a flag for whether computations are done in-place (with states represented by vectors), out-of-place (with state represented by StaticArrays), or on GPUs (with states represented by cuArrays).\n\n\n\n\n\n","category":"type"},{"location":"module_index/#GuidedProposals.HFcBuffer","page":"Index","title":"GuidedProposals.HFcBuffer","text":"struct HFcBuffer{\n        T,D,TB,Tβ,Tσ,Ta,Tmat,Tvec\n        } <: DiffusionDefinition.AbstractBuffer{T}\n    data::Vector{T}\n    B::TB\n    β::Tβ\n    σ::Tσ\n    a::Ta\n    mat::Tmat\n    vec::Tvec\nend\n\nA buffer for temporary computations of in-place ODE solvers solving for H,F,c system.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#GuidedProposals.HFcContainer","page":"Index","title":"GuidedProposals.HFcContainer","text":"struct HFcContainer{T,D,TH,TF,Tc} <: AbstractBuffer{T}\n    data::Vector{T}\n    H::TH\n    F::TF\n    c::Tc\nend\n\nA buffer containing data for in-place computations of H,F,c terms.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#GuidedProposals.HFcSolver","page":"Index","title":"GuidedProposals.HFcSolver","text":"struct HFcSolver{Tmode,Tsv,Tps,Tcb,Ts,T,Ta} <: AbstractGuidingTermSolver{Tmode}\n    saved_values::Tsv\n    problem_setup::Tps\n    callback::Tcb\n    solver::Ts\n    HFc0::T\n    access::Ta\nend\n\nStruct for solving a (H,F,c)-system of ODEs.\n\n    HFcSolver(\n        ::Val{:inplace},\n        tt,\n        xT_plus,\n        P,\n        obs,\n        choices,\n    )\nConstructor for an ODE solver with in-place operations. Pre-allocates space\nand solves a (H,F,c)-system of ODEs once, backward in time on the interval\n`(tt[1], tt[end])`, with a terminal condition computed from `xT_plus`. `P`\nis the auxiliary diffusion law, `obs` is the observation made at time\n`tt[end]` and `choices` contains information about eltype and the algorithm\nfor solving ODEs. H,F,c are saved on a grid of time-points `tt`.\n\n    HFcSolver(\n        ::Val{:outofplace},\n        tt,\n        xT_plus,\n        P,\n        obs,\n        choices\n    )\nConstructor for an ODE solver with out-of-place operations using\nStaticArrays. Initialises the object and solves a (H,F,c)-system of ODEs\nonce, backward in time on the interval `(tt[1], tt[end])`, with a terminal\ncondition computed from `xT_plus`. `P` is the auxiliary diffusion law, `obs`\nis the observation made at time `tt[end]` and `choices` contains information\nabout eltype and the algorithm for solving ODEs. H,F,c are saved on a grid\nof time-points `tt`.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#GuidedProposals.IntegrationRule","page":"Index","title":"GuidedProposals.IntegrationRule","text":"IntegrationRule\n\nSupertype of all integration rules. In this package we currently approximate the integrals by step functions with evaluations at the left side of the intervals.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#GuidedProposals.LeftRule","page":"Index","title":"GuidedProposals.LeftRule","text":"LeftRule <: IntegrationRule\n\nIntegration rule flag, indicating to approximate functions with step functions with height equal to function evaluation at the left side of the intevals.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#Base.Libc.time-Tuple{GuidProp,Any}","page":"Index","title":"Base.Libc.time","text":"Base.time(P::GuidProp, i)\n\nReturn time-point tt[i] corresponding to a saved state of ODEs (with tt[1] indicating time 0+ and tt[end] indicating time T).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.rand","page":"Index","title":"Base.rand","text":"Base.rand(\n    [rng::Random.AbstractRNG], P::GuidProp, y1=zero(P); f=DD.__DEFAULT_F\n)\n\nSample a trajectory of a guided proposal P started from y1. Initialize containers in the background and compute the functional f at the time of sampling.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Base.rand","page":"Index","title":"Base.rand","text":"Base.rand(\n    [rng::Random.AbstractRNG],\n    PP::AbstractArray{<:GuidProp}, y1=zero(PP[1]); f=DD.__DEFAULT_F\n)\n\nSample a trajectory started from y1, defined for multiple guided proposals PP that correspond to consecutive intervals. Initialize containers in the background and compute the functionals f (one for each interval) at the time of sampling.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#DiffusionDefinition.constdiff-Tuple{GuidProp}","page":"Index","title":"DiffusionDefinition.constdiff","text":"\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionDefinition.dimension-Tuple{GuidProp}","page":"Index","title":"DiffusionDefinition.dimension","text":"DD.dimension(P::GuidProp)\n\nDimension of the stochastic process and the driving Brownian motion (by default the same as that of the target process)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.HFc0-Tuple{GuidProp}","page":"Index","title":"GuidedProposals.HFc0","text":"HFc0(P::GuidProp)\n\nReturn the container with data that can be used to reconstruct H,F,c evaluated at time 0+ for the guided proposal P.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.HFc0-Tuple{GuidedProposals.HFcSolver}","page":"Index","title":"GuidedProposals.HFc0","text":"HFc0(s::HFcSolver)\n\nReturn the data containing H,F,c terms for the time 0+\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.fetch_eltype-Tuple{Any,Any}","page":"Index","title":"GuidedProposals.fetch_eltype","text":"fetch_eltype(choices, P)\n\nDetermine the type of the elements that is supposed to be used by the internal containers of this package. If choice.gradients flag is turned on, then use the same type as the eltypes of the parameters in the auxiliary law. Otherwise, use the type specified in choice. If neither the choice.gradients flag is on, nor a default is provided, use Float64.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.fetch_xT_plus","page":"Index","title":"GuidedProposals.fetch_xT_plus","text":"fetch_xT_plus(::Val{:inplace}, next_guided_prop, el, dim_of_proc)\n\nIf this is not the last inter-observation interval, fetch the data containing H,F,c computed for the left time-limit of the subsequent interval. Otherwise, instantiate a zero-term.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#GuidedProposals.get_or_default-Tuple{Any,Symbol,Any}","page":"Index","title":"GuidedProposals.get_or_default","text":"get_or_default(container, elem::Symbol, default)\n\nReturn container.elem if it exists, otherwise return default\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.init_solver-Tuple{Val{:hfc},Any,Any,Any,Any,Val,Any,Any}","page":"Index","title":"GuidedProposals.init_solver","text":"init_solver(\n    ::Val{:hfc},\n    ::Any,\n    tt,\n    P_aux,\n    obs,\n    mode::Val,\n    choices,\n    next_guided_prop\n)\n\nInitialise ODE solver for H,F,c, preallocate space and solve it once. tt is the time-grid on which ∇logρ is to be saved. P_aux is the auxiliary law, obs is the terminal observation, mode is for differentiating between in-place, out-of-place and gpu constructors for the guiding term solver, choices contains additional information that is passed on (and which is about eltype and a chosen algorithm for the ODE solvers) and finally, next_guided_prop is the guided proposal used on the subsequent inter-observation interval.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.mode-Tuple{GuidProp}","page":"Index","title":"GuidedProposals.mode","text":"mode(P::GuidProp)\n\nReturn the mode of solving ODE systems (:inplace, :outofplace or :gpu) [TODO not used much, for multiple dispatch needs to return Val{mode}() instead, change  or remove].\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.outer-Tuple{Any}","page":"Index","title":"GuidedProposals.outer","text":"outer(x)\n\nCompute an outer product\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.prepare_static_saving_types-Union{Tuple{D}, Tuple{Val{:hfc},Val{D},Any}} where D","page":"Index","title":"GuidedProposals.prepare_static_saving_types","text":"prepare_static_saving_types(::Val{:hfc}, ::Val{D}, el) where D\n\nDefine data-types for H,F,c computed by out-of-place solver that are to be saved internally.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.reformat-Tuple{NamedTuple,Bool,Any}","page":"Index","title":"GuidedProposals.reformat","text":"reformat(solver_choice::NamedTuple, last_interval::Bool, P_aux)\n\nRe-format the solver_choice by splitting it into two NamedTuples and populating any missing entries with defaults. P_aux is the law of the auxiliary diffusion that is needed in case a flag for computing gradients is turned on.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.size_of_HFc_buffer-Tuple{Any}","page":"Index","title":"GuidedProposals.size_of_HFc_buffer","text":"size_of_HFc_solution(d)\n\nLength of a vector containing temporary data needed for in-place solver of H,F,c, when the underlying process has dimension d.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.size_of_HFc_solution-Tuple{Any}","page":"Index","title":"GuidedProposals.size_of_HFc_solution","text":"size_of_HFc_solution(d)\n\nCompute the size of a vector containing H,F,c elements\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.solve_and_ll!-NTuple{4,Any}","page":"Index","title":"GuidedProposals.solve_and_ll!","text":"solve_and_ll!(XX, WW, P, y1)\n\nCompute the trajectory under the law P for a given Wiener noise W and a starting point y1. Store the trajectory in XX. Compute the log-likelihood (path contribution) along the way. Return success_flag and log-likelihood. success_flag is set to false only if sampling was prematurely halted due to XX violating assumptions about state space.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.static_accessor_HFc-Union{Tuple{T}, Tuple{K}, Tuple{K,Val{T}}} where T where K<:Union{StaticArrays.MArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S},T,1,S} where T where S}","page":"Index","title":"GuidedProposals.static_accessor_HFc","text":"static_accessor_HFc(u::SVector, ::Val{T}) where T\n\nAccess data stored in the container u so that it matches the shapes of H,F,c and points to the correct points in u. T is the dimension of the stochastic process.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.update_HFc!-Tuple{Any,Any,Any}","page":"Index","title":"GuidedProposals.update_HFc!","text":"update_HFc!(u_T, u_Tplus, obs, access)\n\nUpdate equations for H,F,c at the times of observations. Save the data into u_T.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.update_HFc-Tuple{Any,Any,Any}","page":"Index","title":"GuidedProposals.update_HFc","text":"update_HFc(u_Tplus, obs, access)\n\nUpdate equations for H,F,c at the times of observations.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.clone-Tuple{GuidProp,Any,Any}","page":"Index","title":"ObservationSchemes.clone","text":"ObservationSchemes.clone(P::GuidProp, θ°, η°)\n\nCreate a new guided proposal object with new parameters θ° parametrizing the diffusion laws and η° parametrizing the observations. Keep the pre-allocated spaces for solvers unchanged. Note that θ° must be a dictionary correspond to parameters returned when calling DD.var_parameters() on the target and auxiliary laws.\n\nTODO this is a convenience method that is not really used and doesn't properly work yet.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.clone-Union{Tuple{T}, Tuple{T,Any,Any,Any,Any}} where T<:GuidProp","page":"Index","title":"ObservationSchemes.clone","text":"ObservationSchemes.clone(P::GuidProp, ξ, invcoords, θ°idx, η°idx)\n\nCreate a new guided proposal object with new parameters (slightly akward method, but optimized for speed in an MCMC setting). ξ should contain all parameters that are changing. It is a sub-vector of a larger global vector ξ°. The positions taken by ξ in ξ° are given by sub_idx (which is not known to a method), and invcoords is a dictionary that for each entry in sub_idx gives a corresponding index of ξ. The indices of ξ° that constitute parameters to be passed to cloning of law are listed in θ°idx. In particular, if θ°idx were just a list of indices, then θ° = ξ°[θ°idx]. However, θ°idx additionally contains parameter names. η°idx does the same but for the observation. Keeps the pre-allocated spaces for solvers unchanged.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX°, WW°, WW, ρρ, y1=zero(PP[1]);\n    f=DD.__DEFAULT_F, f_out=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX° and WW° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameters ρρ (one for each interval) and a previously sampled Wiener noise WW. Compute the functionals f (one for each interval) at the time of sampling and store the results in f_out.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX, WW, y1=zero(PP[1]);\n    f=DD.__DEFAULT_F, f_out=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX and WW to save the results. Compute the functionals f (one for each interval) at the time of sampling and store the results in f_out.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG]\n    P::GuidProp,\n    X°, W°, W, ρ, v::Val{:ll}, y1=zero(P);\n    Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X° and W° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter ρ and a previously sampled Wiener noise W. Compute log-likelihood (only path contribution) along the way.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX°, WW°, WW, ρρ, v::Val{:ll}, y1=zero(PP[1]);\n    Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX° and WW° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameters ρρ (one for each interval) and a previously sampled Wiener noise WW. Compute log-likelihood (path contribution AND end-points contribution) along the way.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG]\n    P::GuidProp,\n    X, W, v::Val{:ll}, y1=zero(P);\n    Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X and W to save the results. Compute log-likelihood (only path contribution) along the way.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX, WW, v::Val{:ll}, y1=zero(PP[1]);\n    Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX° and WW° to save the results. Compute log-likelihood (path contribution AND end-points contribution) along the way.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG],\n    P::GuidProp,\n    X°, W°, W, ρ, y1=zero(P);\n    f=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X° and W° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter ρ and a previously sampled Wiener noise W. Compute the functional f at the time of sampling.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Random.rand!","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG],\n    P::GuidProp,\n    X, W, y1=zero(P);\n    f=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X and W to save the results. Compute the functional f at the time of sampling.\n\n\n\n\n\n","category":"function"},{"location":"get_started/overview/#get_started-1","page":"Get started","title":"Installation","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"The package is not registered yet. To install it write:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"] add https://github.com/JuliaDiffusionBayes/GuidedProposals.jl","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"note: Note\nThe package depends on DiffusionDefinition.jl and ObservationSchemes.jl, neither of which is registered yet. Install them in the same way as GuidedProposals.jl.","category":"page"},{"location":"get_started/overview/#gp-1","page":"Get started","title":"gp","text":"","category":"section"},{"location":"manual/multiple_obs/#Guided-proposals-with-multiple-observations-1","page":"Multiple observations","title":"Guided proposals with multiple observations","text":"","category":"section"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"In practice, it is often of interest to sample from some target diffusion law","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"dd X_t = b(tX_t)dd t + sigma(tX_t) dd W_tquad tin0Tquad X_0sim p_0","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"conditionally on multiple, partial observations of X:","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"V_t_i=left L_iX_t_i+eta_ii=1dotsN rightquad L_iinRR^m_itimes dquad eta_isim N(mu_iSigma_i)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"not only a single one. This can be done by stacking together GuidProp, each defined on its own interval t_i-1t_i and for its own terminal observation V_t_i. The initialization may be done implicitly if you call","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"GuidedProposals.build_guid_prop","category":"page"},{"location":"manual/multiple_obs/#GuidedProposals.build_guid_prop","page":"Multiple observations","title":"GuidedProposals.build_guid_prop","text":"build_guid_prop(\n    ::Type{AuxLaw}, recording::NamedTuple, tts::Vector, args...\n) where {AuxLaw <: DD.DiffusionProcess}\n\nInitialize multiple instances of GuidProp corresponding to guided proposals for observations stored in recording. The time grids for each inter-observation interval is given in tts and AuxLaw is the auxiliary law for creating guided proposals. args... are passed to each constructor of GuidProp.\n\n\n\n\n\nbuild_guid_prop(\n    aux_laws::AbstractArray, recording::NamedTuple, tts::Vector, args\n)\n\nSame as a version with ::Type{AuxLaw}, but aux_laws is a list of auxiliary laws that correspond to each inter-observation interval.\n\n\n\n\n\n","category":"function"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"For instance:","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"observs = load_data(\n    ObsScheme(\n        LinearGsnObs(\n            0.0, zero(SVector{2,Float64});\n            Σ = 1e-4*SDiagonal(1.0, 1.0)\n        )\n    ),\n    [1.0, 2.0, 3.0],\n    [[2.2, 0.7], [0.9, 1.0], [0.5, 0.8]]\n)\n\nrecording = (\n    P = P_target,\n    obs = observs,\n    t0 = 0.0,\n    x0_prior = undef # normally, we would provide a prior, however for the steps\n    # below it is not needed\n)\ntts = OBS.setup_time_grids(recording, 0.001)\n\nPP = build_guid_prop(LotkaVolterraAux, recording, tts)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"where we have packaged the observations in a format of a recording from ObservationSchemes.jl","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"note: Note\nIt is possible to perform the steps hidden behind a call to build_guid_prop explicitly. To properly initialize the guiding term we must defined the sequence of GuidProp starting from the last interval t_N-1t_N and proceed moving backwards: t_N-2t_N-1dots0t_1, each time passing a GuidProp from the subsequent interval t_it_i+1 to the GuidProp that is being defined on t_i-1t_i. For the observations above this becomes:P_intv3 = GuidProp(tts[3], P_target, LotkaVolterraAux, observs[3])\nP_intv2 = GuidProp(tts[2], P_target, LotkaVolterraAux, observs[2]; next_guid_prop=P_intv3)\nP_intv1 = GuidProp(tts[1], P_target, LotkaVolterraAux, observs[1]; next_guid_prop=P_intv2)That's it, now a vectorP = [P_intv1, P_intv2, P_intv3]is equivalent to PP defined before. Needless to say, calling build_guid_prop instead is recommended.","category":"page"},{"location":"manual/multiple_obs/#Sampling-a-single-trajectory-1","page":"Multiple observations","title":"Sampling a single trajectory","text":"","category":"section"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"Sampling is done analogously to how it was done for a case of a single observation. Simply call rand if you wish to have containers initialized in the background:","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"# sample\nXX, WW, Wnr = rand(PP, y1)\n\n# build a plot\np = plot()\nfor i in 1:3\n    plot!(p, XX[i], Val(:x_vs_y); color=\"steelblue\",label=\"\")\nend\nscatter!(p, [y1[1]],[y1[2]], markersize=8, label=\"starting point\")\nfor i in 1:3\n\t  o = OBS.obs(recording.obs[i])\n    scatter!(p, [o[1]], [o[2]]; label=\"observation $i\", markersize=8, marker=:diamond, markercolor=\"orange\")\nend\ndisplay(p)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"(Image: guid_prop_multi)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"Alternatively, initialize containers yourself and then call rand!:","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"XX, WW = trajectory(PP)\nrand!(PP, XX, WW, y1)","category":"page"},{"location":"manual/multiple_obs/#Sampling-multiple-trajectories-1","page":"Multiple observations","title":"Sampling multiple trajectories","text":"","category":"section"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"As it was the case with single observation, sampling multiple trajectories often involves computation of the log-likelihood. Analogously to how it was explained in the previous section, there are three ways of computing log-likelihood and the preferred way is to use the optimized rand! samplers that compute log-likelihoods as the path is being sampled.","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"success, ll = rand!(PP, XX, WW, Val(:ll), y1)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"Smoothing is now as simple as it was for a single observation. In fact, thanks to the magic of Julia's multiple dispatch we may call the exact same function simple_smoothing that was defined in the previous section and it will work for multiple observations as well!","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"paths = simple_smoothing(P, y1)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"(Image: lotka_volterra_simple_smoothing_multi)","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"note: Note\nA log-likelihood computed by rand! for a list of trajectories is slightly different than the log-likelihood computed for a single segment. An additional term due to transition densities is added. See the section on log-likelihoods for more details.","category":"page"},{"location":"manual/multiple_obs/#Preconditioned-Crank-Nicolson-scheme-1","page":"Multiple observations","title":"Preconditioned Crank-Nicolson scheme","text":"","category":"section"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"Perturbing Gaussian noise instead of sampling it anew works in exactly the same way as in the previous section.","category":"page"},{"location":"manual/multiple_obs/#","page":"Multiple observations","title":"Multiple observations","text":"XX°, WW° = trajectory(PP)\nρρ = [0.5, 0.8, 0.4] # one memory param for each interval\nrand!(PP, XX°, WW°, WW, ρρ, y1)","category":"page"},{"location":"manual/reparameterizations/#Reparameterizations-of-GuidProp-1","page":"Reparameterizations","title":"Reparameterizations of GuidProp","text":"","category":"section"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"","category":"page"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"In an MCMC setting we may wish to change the values of some parameters of GuidProp. GuidProp is defined as an immutable struct, so in-place change will usually be impossible; however, we can use a function clone to create a new instance of GuidProp with new parameter values and the remaining containers simply kept unchanged from a previous GuidProp instance","category":"page"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"GuidedProposals.clone","category":"page"},{"location":"manual/reparameterizations/#ObservationSchemes.clone","page":"Reparameterizations","title":"ObservationSchemes.clone","text":"ObservationSchemes.clone(P::GuidProp, θ°, η°)\n\nCreate a new guided proposal object with new parameters θ° parametrizing the diffusion laws and η° parametrizing the observations. Keep the pre-allocated spaces for solvers unchanged. Note that θ° must be a dictionary correspond to parameters returned when calling DD.var_parameters() on the target and auxiliary laws.\n\nTODO this is a convenience method that is not really used and doesn't properly work yet.\n\n\n\n\n\nObservationSchemes.clone(P::GuidProp, ξ, invcoords, θ°idx, η°idx)\n\nCreate a new guided proposal object with new parameters (slightly akward method, but optimized for speed in an MCMC setting). ξ should contain all parameters that are changing. It is a sub-vector of a larger global vector ξ°. The positions taken by ξ in ξ° are given by sub_idx (which is not known to a method), and invcoords is a dictionary that for each entry in sub_idx gives a corresponding index of ξ. The indices of ξ° that constitute parameters to be passed to cloning of law are listed in θ°idx. In particular, if θ°idx were just a list of indices, then θ° = ξ°[θ°idx]. However, θ°idx additionally contains parameter names. η°idx does the same but for the observation. Keeps the pre-allocated spaces for solvers unchanged.\n\n\n\n\n\n","category":"function"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"The first clone method is not working yet (but it's also not of much use). The second method seems a bit convoluted, but it is all for optimizing performance for the MCMC setting. To understand how to use it consider the following example:","category":"page"},{"location":"manual/reparameterizations/#Example-1","page":"Reparameterizations","title":"Example","text":"","category":"section"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"","category":"page"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"# This `global vector` corresponds to all parameters of the MCMC chain\n# (possibly many more than there in a single GuidProp)\nξ° = collect(1.0:10.0)\n\n# These coordinates of the global vector are relevant for a `clone` call\nsub_idx = [3, 5, 7]\n\n# To each coordinate in `sub_idx` associate an index in `ξ`\ninvcoords = Dict(\n\t3 => 1,\n\t5 => 2,\n\t7 => 3,\n)\n\n# build `local vector` (corresponding to a local update of an MCMC chain)\nξ = ξ°[sub_idx] # [3.0, 5.0, 7.0]\n\n# info on which parameters to update. For laws associate by name,\n# for observations (not considered here) associate by position (instead of pname use local_idx)\nθ°idx = [\n\t(global_idx=sub_idx[1], pname=:β),\n\t(global_idx=sub_idx[2], pname=:γ),\n\t(global_idx=sub_idx[3], pname=:α),\n]\n\n# clone\nP_cloned = GP.clone(P, ξ, invcoords, θ°idx, [])","category":"page"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"Now we have:","category":"page"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"julia> DD.var_parameters(P_cloned.P_target)\nDict{Symbol,Float64} with 6 entries:\n  :α  => 7.0\n  :γ  => 5.0\n  :δ  => 1.0\n  :β  => 3.0\n  :σ2 => 0.1\n  :σ1 => 0.1\n\njulia> DD.var_parameters(P_cloned.P_aux) == DD.var_parameters(P_cloned.P_target)\ntrue","category":"page"},{"location":"manual/reparameterizations/#Re-computing-the-guiding-term-1","page":"Reparameterizations","title":"Re-computing the guiding term","text":"","category":"section"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"","category":"page"},{"location":"manual/reparameterizations/#","page":"Reparameterizations","title":"Reparameterizations","text":"Sometimes changing parameter values is all that needs to be done; however, it is not always the case. Sometimes changing parameter values implies that the terms used for computation of the guiding term also need to be updated. To see ...","category":"page"},{"location":"manual/convenience/#Utility-functions-1","page":"Convenience functions","title":"Utility functions","text":"","category":"section"},{"location":"manual/convenience/#","page":"Convenience functions","title":"Convenience functions","text":"We implemented some utility functions for computing the log-likelihoods, sampling the paths, accessing various elements related to guiding terms (and probably there will be more functions implemented in the near future).","category":"page"},{"location":"manual/convenience/#Computing-the-log-likelihoods-1","page":"Convenience functions","title":"Computing the log-likelihoods","text":"","category":"section"},{"location":"manual/convenience/#","page":"Convenience functions","title":"Convenience functions","text":"Probably the most important functions are loglikhd and loglikhd_obs. The former computes the logarithm of a Girsanov transform between the target and proposal laws evaluated at a sampled path:","category":"page"},{"location":"manual/convenience/#","page":"Convenience functions","title":"Convenience functions","text":"ll° = loglikhd(XX[1], P[1])","category":"page"},{"location":"manual/convenience/#","page":"Convenience functions","title":"Convenience functions","text":"The latter evaluates the logarithm of the auxiliary ρ(x0,xT) function (i.e. the contribution due to the end-points that is not canceled in importance/mcmc sampling schemes).","category":"page"},{"location":"manual/convenience/#","page":"Convenience functions","title":"Convenience functions","text":"ll° = loglikhd_obs(P[1], x0)","category":"page"},{"location":"manual/log_likelihood/#log_likelihood_computations-1","page":"Log-likelihoods","title":"Computations of log-likelihoods","text":"","category":"section"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"The full likelihood function for a sampled path X given by:","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"frac\n    colorforestgreen\n        tilderho(0X_0)\n    \n\n    colormaroon\n        rho(0X_0)\n    \nexpleft\n    colorroyalblue\n        int_0^T G(t X_t) dd t\n    \nright","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"where","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"G(tx)=left\n    (b-tildeb)^Ttilder\n    + 05 trleft\n        (a-tildea)(tildertilder^T-H)\n    right\nright(tx)","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"and tilder(tx)=nablalogtilderho(tx). The terms colorroyalblueint_0^T G(t X_t) dd t, and logleft(colorforestgreentilderho(0X_0)right) may be computed with functions:","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"GuidedProposals.loglikhd","category":"page"},{"location":"manual/log_likelihood/#GuidedProposals.loglikhd","page":"Log-likelihoods","title":"GuidedProposals.loglikhd","text":"loglikhd([::IntegrationRule=::LeftRule], X::Trajectory, P::GuidProp; skip=0)\n\nCompute path contribution to the log-likelihood function, i.e.:\n\nint_0^T G(t X_t) dt\n\nwhere\n\nG(tx)=left\n    (b-tildeb)^Ttilder\n    + 05 trleft\n        (a-tildea)(tildertilder^T-H)\n    right\nright(tx)\n\nand tilder(tx)=nablalogtilderho(tx).\n\nloglikhd(\n    [::IntegrationRule=::LeftRule],\n    XX::AbstractArray{<:Trajectory}, PP::AbstractArray{<:GuidProp};\n    skip=0\n)\n\nCompute path contribution to the log-likelihood function for a sequence of segments.\n\n\n\n\n\n","category":"function"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"and","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"GuidedProposals.loglikhd_obs","category":"page"},{"location":"manual/log_likelihood/#GuidedProposals.loglikhd_obs","page":"Log-likelihoods","title":"GuidedProposals.loglikhd_obs","text":"loglikhd_obs(P::GuidProp, x0)\n\nCompute the contribution of end-points to the log-likelihood function, i.e.: logrho(tx).\n\n\n\n\n\n","category":"function"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"respectively. In general, deriving the term colormaroonrho(0X_0) explicitly is impossible. Thankfully though, in an MCMC or an importance sampling setting this term always cancels out and so never needs to be computed.","category":"page"},{"location":"manual/log_likelihood/#Log-likelihood-computation-whilst-sampling-1","page":"Log-likelihoods","title":"Log-likelihood computation whilst sampling","text":"","category":"section"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"Function rand!—when called with a parameter Val(:ll)—computes the \"log-likelihood\" at the time of sampling. Internally the following function is called after the Wiener process is sampled.","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"GuidedProposals.solve_and_ll!","category":"page"},{"location":"manual/log_likelihood/#GuidedProposals.solve_and_ll!","page":"Log-likelihoods","title":"GuidedProposals.solve_and_ll!","text":"solve_and_ll!(XX, WW, P, y1)\n\nCompute the trajectory under the law P for a given Wiener noise W and a starting point y1. Store the trajectory in XX. Compute the log-likelihood (path contribution) along the way. Return success_flag and log-likelihood. success_flag is set to false only if sampling was prematurely halted due to XX violating assumptions about state space.\n\n\n\n\n\n","category":"function"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"solve_and_ll! computes only colorroyalblueint_0^T G(t X_t) dd t.","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"When rand! is called on a single GuidProp (i.e. a single interval) then only this path contribution is returned.\nHowever, if rand! is called on a list of GuidProp, then apart from summing over the results from solve_and_ll! an additional end-point contribution is added, i.e.","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"colorroyalblueint_0^T G(t X_t) dd t+logleft(colorforestgreentilderho(0X_0)right)","category":"page"},{"location":"manual/log_likelihood/#","page":"Log-likelihoods","title":"Log-likelihoods","text":"is returned.","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#tutorials_start-1","page":"Understanding in-place vs out-of-place","title":"Understanding in-place vs out-of-place methods and how to call them","text":"","category":"section"},{"location":"how_to_guides/sample_bridges/#how_to_guides-1","page":"Sample diffusion bridges","title":"How to sample diffusion bridges","text":"","category":"section"},{"location":"manual/ode_type/#ode_types-1","page":"ODE systems","title":"ODE systems for computing the guiding term","text":"","category":"section"},{"location":"manual/ode_type/#","page":"ODE systems","title":"ODE systems","text":"The guiding term can be computed in a variety of ways. Here, we provide three distinct methods–-corresponding to solving three systems of ODEs–-for achieving this feat.","category":"page"},{"location":"manual/ode_type/#TODO-direct-computations-via-matrix-exponentials-(doubling-etc.)-without-having-to-1","page":"ODE systems","title":"TODO direct computations via matrix exponentials (doubling etc.) without having to","text":"","category":"section"},{"location":"manual/guid_prop/#manual_start-1","page":"Guided proposals","title":"Defining guided proposals","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"The main object used to define guided proposals is","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"GuidedProposals.GuidProp","category":"page"},{"location":"manual/guid_prop/#GuidedProposals.GuidProp","page":"Guided proposals","title":"GuidedProposals.GuidProp","text":"struct GuidProp{\n        K,DP,DW,SS,R,R2,O,S,T\n        } <: DiffusionDefinition.DiffusionProcess{K,DP,DW,SS}\n    P_target::R\n    P_aux::R2\n    obs::O\n    guiding_term_solver::S\nend\n\nStruct defining guided proposals of M Schauer, F van der Meulen and H van Zanten. See Mider M, Schauer M and van der Meulen F \"Continuous-discrete smoothing of diffusions\" (2020) for a comprehensive overview of the mathematics behind this object. It computes and stores the guiding term ∇logρ and allows for simulation of guided proposals and computation of their likelihood.\n\nGuidProp(\n        tt,\n        P_target::R,\n        P_aux_type::Type{TR2},\n        obs::O,\n        solver_choice=(\n            solver=Tsit5(),\n            ode_type=:HFc,\n            convert_to_HFc=false,\n            mode=:inplace,\n            gradients=false,\n            eltype=Float64,\n        ),\n        next_guided_prop=nothing\n    ) where {\n        R<:DD.DiffusionProcess,\n        TR2<:DD.DiffusionProcess,\n        O<:OBS.Observation\n    }\n\nDefault constructor. P_target and P_aux are the target and the type of the auxiliary diffusion laws respectively, tt is the time-grid on which ∇logρ needs to be computed. obs is the terminal observation (and the only one on the interval (tt[1], tt[end]]). solver_choice specifies the type of ODE solver that is to be used for computations of ∇logρ     ( it is a NamedTuple, where solver specifies the algorithm for solving     ODEs (see the documentation of DifferentialEquations.jl for possible     choices), ode_type picks the ODE system (between :HFc, :MLμ and :Pν),     convert_to_HFc indicates whether to translate the results of M,L,μ solver     to H,F,c objects, mode is a flag indicating the way in which data is being     handled:     - :inplace: uses regular arrays to store the data (requires functions                   B!, β!, σ! and a! to be defined)     - :outofplace: operates on static arrays     - :gpu: operates on GPU arrays [TODO not implemented yet]     gradients is a flag indicating whether automatic differentiation is to     be employed and eltype indicates the data-type of each container's     member. ) Finally, next_guided_prop is the guided proposal for the subsequent inter-observation interval.\n\n\n\n\n\n","category":"type"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"The main role of this object is to facilitate sampling of diffusion paths from some target diffusion law by:","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"drawing from a proposal diffusion law &\ncomputing an importance sampling weight","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"Performing these two steps in a setting of importance sampling or mcmc sampling makes it possible to draw sample-paths from the target law.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"note: Note\nFrom the conceptual point of view, the target and auxiliary laws, as well as the terminal observations are all required to define a guided proposal. However, conceptually, guided proposals are defined as continuous-time processes, and thus, it should be possible to look-up the value of any sampled trajectory at any time tin0T. tt— the time grid on which the path is to be revealed—is thus conceptually superfluous at the time of initialization. Nonetheless, for the purposes that this package was created fixing a time-grid tt at initialization of any GuidProp is helpful in reducing the computational cost of the algorithm. Currently, if sampling on finer grid is needed at any point, then GuidProp object needs to be redefined.","category":"page"},{"location":"manual/guid_prop/#Defining-the-target-law-1","page":"Guided proposals","title":"Defining the target law","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"To define the target law we should make use another package from the JuliaDiffusionBayes suite: DiffusionDefinition.jl. We can either define the target law using the macro @define_diffusion or—if we can—simply load in a pre-defined processes.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"tip: Running example—Lotka-Volterra model—defining the target law\nusing DiffusionDefinition\nconst DD = DiffusionDefinition\n@load_diffusion LotkaVolterra # for constructing the target law\n\nθ = [2.0/3.0, 4.0/3.0, 1.0, 1.0, 0.2, 0.2]\nP_target = LotkaVolterra(θ...)","category":"page"},{"location":"manual/guid_prop/#Defining-the-auxiliary-law-1","page":"Guided proposals","title":"Defining the auxiliary law","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"When we pass the auxiliary law to GuidProp we pass only the name of a struct that defines it and not the actual instance of it. The object will be initialized internally by GuidProp. For this reason, the following convention MUST be adhered to:","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"the auxiliary law is limited to having the same parameter names as the target law; internally GuidProp cycles through all parameters needed by the auxiliary law and looks for the corresponding entry in the target law and uses values of the corresponding parameters found there. Importantly, the association is done by name\nin addition to parameters the auxiliary law is expected to have the following fields of the type :auxiliary_info:\n:t0\n:T\n:vT","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"Additionally, the field :xT will be defined automatically and (if need be) auto-initialized (but can also be declared explicitly).","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"warning: Warning\nNo other field from :auxiliary_info (apart from explicitly declaring :xT) can be used (i.e. fields :v0 and :x0). This last restriction will probably be relaxed in the near future.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"tip: Running example—Lotka-Volterra model—defining the auxiliary law\n@load_diffusion LotkaVolterraAux","category":"page"},{"location":"manual/guid_prop/#Defining-the-terminal-observation-1","page":"Guided proposals","title":"Defining the terminal observation","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"To define the terminal observation we should make use of another package from the JuliaDiffusionBayes.jl suite: ObservationSchemes.jl.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"tip: Running example—Lotka-Volterra model—defining the observation\nLet's initialize an observation sampled according to a scheme: $ v=X+\\eta,\\quad \\eta\\sim N(0,I). $using ObservationSchemes, StaticArrays\nt, xₜ = 3.0, @SVector [0.5, 0.8]\nobs = LinearGsnObs(t, xₜ; Σ=1e-4*SDiagonal{2,Float64}(I))","category":"page"},{"location":"manual/guid_prop/#Initializing-GuidProp-1","page":"Guided proposals","title":"Initializing GuidProp","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"It is now possible to define GuidProp. We may specify the time-grid, and then, leave the remaining parameters at their defaults. At initialization time a sequence of computations is performed that derive a guiding term for t's lying on a pre-specified time-grid tt, as well as some additional quantities that are needed for computations of the log-likelihoods.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"tip: Running example—Lotka-Volterra model—defining GuidProp\ndt = 0.001\ntt = 0.0:dt:t\nP = GuidProp(tt, P_target, LotkaVolterraAux, obs)","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"note: Note\nIf at any point the parameters change, then the guiding term might need to be re-computed (in fact, this is the centerpiece of the backward filtering part of the forward filtering-backward guiding algorithm). We provide certain utility functions that facilitate these operations. See ... for more details.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"note: Note\nAdditional set of options passed to GuidProp are specified in the field solver_choice, which by default is set to:solver_choice=(\n      solver=Tsit5(),\n      ode_type=:HFc,\n      convert_to_HFc=false,\n      mode=:outofplace,\n      gradients=false,\n      eltype=Float64,\n)The constructor expects it to be a NamedTuple with the respective fields (but it is robust enough to fill-in any missing fields with defaults). The meaning of the fields is as follows:solver is passed to DifferentialEquations.jl to pick an algorithm for solving ODEs that define the guiding term. More about the ODE systems is written in ODE types.\node_type is used to pick between three choices of ODE systems to use: H, F, c system, M, L, μ system and P, ν (and c, but c needs to be added to names). They have the labels: :HFc, MLμ, Pν respectively, which are not case sensitive and currently only HFc is implemented)\nconvert_to_HFc is used only when :MLμ has been chosen to be a solver of ODEs. In that scenario, if convert_to_HFc is set to true, then the terms M, L, μ that the ODE systems solve for will be used to compute the corresponding H, F, c terms (as opposed to using :HFc solver to solve for them)\nmode is an important flag (currently only :outofplace is fully supported) and it is used to tell GuidProp what type of computations are being performed: out-of-place :outofplace, which are based on SVectors from StaticArrays.jl, in-place :inplace, which are based on Vectors or :gpu, which are based on cuArrays.\ngradients is another important flag for telling GuidProp whether gradients with respect to something need to be computed.\neltype ignore this for a moment, we need to figure some things out with this...","category":"page"},{"location":"manual/guid_prop/#Sampling-guided-proposals-1","page":"Guided proposals","title":"Sampling guided proposals","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"Once GuidProp has been initialized, trajectories of guided proposals may be sampled from it.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"GuidedProposals.rand\nGuidedProposals.rand!","category":"page"},{"location":"manual/guid_prop/#Base.rand","page":"Guided proposals","title":"Base.rand","text":"Base.rand(\n    [rng::Random.AbstractRNG], P::GuidProp, y1=zero(P); f=DD.__DEFAULT_F\n)\n\nSample a trajectory of a guided proposal P started from y1. Initialize containers in the background and compute the functional f at the time of sampling.\n\n\n\n\n\nBase.rand(\n    [rng::Random.AbstractRNG],\n    PP::AbstractArray{<:GuidProp}, y1=zero(PP[1]); f=DD.__DEFAULT_F\n)\n\nSample a trajectory started from y1, defined for multiple guided proposals PP that correspond to consecutive intervals. Initialize containers in the background and compute the functionals f (one for each interval) at the time of sampling.\n\n\n\n\n\n","category":"function"},{"location":"manual/guid_prop/#Random.rand!","page":"Guided proposals","title":"Random.rand!","text":"Random.rand!(\n    [rng::Random.AbstractRNG],\n    P::GuidProp,\n    X, W, y1=zero(P);\n    f=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X and W to save the results. Compute the functional f at the time of sampling.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG],\n    P::GuidProp,\n    X°, W°, W, ρ, y1=zero(P);\n    f=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X° and W° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter ρ and a previously sampled Wiener noise W. Compute the functional f at the time of sampling.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG]\n    P::GuidProp,\n    X, W, v::Val{:ll}, y1=zero(P);\n    Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X and W to save the results. Compute log-likelihood (only path contribution) along the way.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG]\n    P::GuidProp,\n    X°, W°, W, ρ, v::Val{:ll}, y1=zero(P);\n    Wnr=Wiener()\n)\n\nSample a trajectory of a guided proposal P started from y1. Use containers X° and W° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameter ρ and a previously sampled Wiener noise W. Compute log-likelihood (only path contribution) along the way.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX, WW, y1=zero(PP[1]);\n    f=DD.__DEFAULT_F, f_out=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX and WW to save the results. Compute the functionals f (one for each interval) at the time of sampling and store the results in f_out.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX°, WW°, WW, ρρ, y1=zero(PP[1]);\n    f=DD.__DEFAULT_F, f_out=DD.__DEFAULT_F, Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX° and WW° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameters ρρ (one for each interval) and a previously sampled Wiener noise WW. Compute the functionals f (one for each interval) at the time of sampling and store the results in f_out.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX, WW, v::Val{:ll}, y1=zero(PP[1]);\n    Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX° and WW° to save the results. Compute log-likelihood (path contribution AND end-points contribution) along the way.\n\n\n\n\n\nRandom.rand!(\n    [rng::Random.AbstractRNG]\n    PP::AbstractArray{<:GuidProp},\n    XX°, WW°, WW, ρρ, v::Val{:ll}, y1=zero(PP[1]);\n    Wnr=Wiener()\n)\n\nSample a trajectory started from y1 over multiple intervals for guided proposals PP that correspond to consecutive intervals. Use containers XX° and WW° to save the results. Use a preconditioned Crank-Nicolson scheme with memory parameters ρρ (one for each interval) and a previously sampled Wiener noise WW. Compute log-likelihood (path contribution AND end-points contribution) along the way.\n\n\n\n\n\n","category":"function"},{"location":"manual/guid_prop/#Sampling-a-single-trajectory-1","page":"Guided proposals","title":"Sampling a single trajectory","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"To sample a single trajectory and initialize appropriate containers in the background call rand. Note that rand returns two containers (one for the underlying process: X and another for the Wiener process: W) and a flag for sampling Wiener process Wnr. X, W and Wnr may then be used with rand! for re-sampling without having to allocate any additional memory.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"tip: Running example—Lotka-Volterra model—sampling a single path\nx0 = @SVector [2.0, 0.25]\nX, W, Wnr = rand(P, x0)\n\nplot(X, Val(:x_vs_y))\nscatter!([y1[1]],[y1[2]], markersize=8, label=\"starting point\")\nscatter!([vT[1]],[vT[2]], marker=:diamond, markersize=8, label=\"conditioned-on point\")(Image: lotka_volterra_single_gp)","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"Alternatively, you may choose to be more explicit: initialize the containers yourself and then call rand!. Note however that if the diffusion's state space is not RR^d you might need to keep re-sampling to make sure the conditions are satisfied.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"# initialize containers\nX, W = trajectory(P)\n# sample the process\nsuccess = false\nwhile !success\n    success, _ = rand!(P, X, W, x0; Wnr=Wiener())\nend","category":"page"},{"location":"manual/guid_prop/#single_obs_multiple_trajectories-1","page":"Guided proposals","title":"Sampling multiple trajectories","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"Of course, sampling a single trajectory of a guided proposal is usually not the end-goal. We are instead interested in sampling from the target law. To this end we need to not only sample paths, but also compute their log-likelihoods. This can be done in three ways.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"First, you may simply call loglikhd after the path has been sampled to compute the log-likelihood for it\nSecond, just as in DiffusionDefinition.jl rand and rand! accept a named argument f which computes path functionals when sampling. A function that computes the log-likelihood may be passed there.\nThird—a preferable method—you may call versions of rand! that have optimized versions of log-likelihood computations implemented for them.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"success, ll = rand!(P, X, W, Val(:ll), x0; Wnr=Wiener())","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"warning: Warning\nll returned by rand! is not exactly log-likelihood for the path XX and one needs to be careful what is the meaning of it. Consult the section on log-likelihoods to find out more.","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"With these functions we may very easily perform smoothing to obtain samples under the target law:","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"function simple_smoothing(P, y1)\n\tX, W, Wnr = rand(P, y1)\n\tX°, W° = trajectory(P)\n\n\tll = loglikhd(X, P)\n\tpaths = []\n\n\tfor i in 1:10^4\n\t\t_, ll° = rand!(P, X°, W°, Val(:ll), y1; Wnr=Wnr)\n\t\tif rand() < exp(ll°-ll)\n\t\t\tX, W, X°, W° = X°, W°, X, W\n\t\t\tll = ll°\n\t\tend\n\t\ti % 400 == 0 && append!(paths, [deepcopy(X)])\n\tend\n\tpaths\nend\npaths = simple_smoothing(P, y1)","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"which results in","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"using Plots, Colors\ncm = colormap(\"RdBu\")\nkwargs = (alpha=0.3, label=\"\")\np = plot(paths[1], Val(:x_vs_y); color=cm[1], kwargs...)\nfor (i,x) in enumerate(paths[2:end])\n\tplot!(p, x, Val(:x_vs_y); color=cm[4*i], kwargs...)\nend\ndisplay(p)","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"(Image: simple_smoothing)","category":"page"},{"location":"manual/guid_prop/#Preconditioned-Crank–Nicolson-scheme-1","page":"Guided proposals","title":"Preconditioned Crank–Nicolson scheme","text":"","category":"section"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"To use the Crank–Nicolson scheme pass additional parameters W (the previously accepted Wiener noise) and ρ (the memory parameter of the preconditioned Crank–Nicolson scheme to a rand! function):","category":"page"},{"location":"manual/guid_prop/#","page":"Guided proposals","title":"Guided proposals","text":"X°, W° = trajectory(P)\nρ = 0.7\nsuccess, ll° = rand!(P, X°, W°, W, ρ, Val(:ll), y1; Wnr=Wnr)","category":"page"},{"location":"manual/bffg/#Backward-filtering-forward-guiding-algorithm-1","page":"BFFG algorithm","title":"Backward filtering-forward guiding algorithm","text":"","category":"section"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"This package implements a computational framework from this paper for computing various terms of guided proposals. In particular, we provide high-level routines that correspond to the two main sweeps of the main algorithm:","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"backward_filter! &\nforward_guide!.","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"Both of them operate on an already initialized vector of GuidProp that corresponds to a recording.","category":"page"},{"location":"manual/bffg/#Forward-guide-1","page":"BFFG algorithm","title":"Forward guide","text":"","category":"section"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"The forward_guide! function is used to sample a trajectory of multiple guided proposals stacked together, targeting some conditional diffusion law, that is conditioned on multiple observations.","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"Let's look at the example from the previous section, were we defined guided proposals for a recording with three observations. We first formalize the definition of a recording by adding a prior over the starting point and then define the guided proposals again:","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"recording = (\n    P = P_target,\n    obs = observs,\n    t0 = 0.0,\n    x0_prior = KnownStartingPt((@SVector [0.5 0.5])),\n)\nP = standard_build_guid_prop(LotkaVolterraAux, recording, tts)","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"Because these functions have been created with the thought in mind of being able to call them repeatedly over and over again in the most efficient way we should now define a couple of containers that are needed to store intermediate states of various simulated objects. These are:","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"A container for sampled driving Brownian motion\nA container for sampled trajectory of a proposal path\nA vector with flags for dimensions/shape/data type of Brownian motions\nA vector of guided proposals","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"Additionally we must provide a starting point to start sampling from, and finally, optionally, we can provide another container with a realization of a Brownian motion and a vector of hyper-parameters (each taking values in 01) for doing the preconditioned Crank-Nicolson scheme. For simplicity let's leave the last to at default values (see the source code for more info). Then, we have the following:","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"WW° = map(tt->trajectory(tt, DD.ℝ{2}), tts)\nXX° = deepcopy(WW°)\nWnr = [Wiener() for _=1:3]\nx0 = rand(recording.x0_prior)","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"We can now sample guided proposals with forward_guide!. The function will output a flag for whether the sampling has been successful (it can fail if the sampled path hits a boundary of the state space on which the process is defined) as well as the log-likelihood (due to sampled path only! in particular the contribution due to end-points is not computed and need to be computed explicitly by calling loglikhd_obs (though the two might be joined in the future)) that is computed alongside the sample. The sampled path is going to be saved to XX°.","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"success, ll° = forward_guide!(WW°, XX°, Wnr, P, x0)","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"The sampled path is stored in a vector of trajectories, so we can use a generic plotting functionality suitable for trajectories from  DiffusionVis.jl (NOTE: not implemented).","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"As a side note, forward_guide! can also be applied directly to an interval so that sampling is done only for a single GuidProp, for instance, we could call:","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"success_single, ll_single° = forward_guide!(WW°[1], XX°[1], Wnr[1], P[1], x0)","category":"page"},{"location":"manual/bffg/#Backward-filter-1","page":"BFFG algorithm","title":"Backward filter","text":"","category":"section"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"A very important functionality of GuidProp is the ability to change the parameters of GuidProp without having to-reallocate almost any memory. This can be done by calling a GuidProp constructor that is specialized in doing such reassignment of parameters:","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"θ° = ... # some new parameterization of the diffusion law\nη° = ... # some new parameterization of the observation\nP1_new = GuidProp(P[1], θ°, η°)","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"Then, internally the parameters in the diffusion laws and observations are changed, but nothing is done about recomputing the guiding terms. Sometimes nothing has to be done, because the parameters have no influence on the computation of the guiding term (in which case we save some resources by avoiding expensive calls to the ODE solvers), other times, the ODE systems need to be solved anew. To re-compute the guiding term for the new parameters all we need to do is call recompute_guiding_term!:","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"recompute_guiding_term!(P1_new)","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"NOTE that the above would not only change the guiding term of P1_new, but also of P[1], because the constructor GuidProp(P[1], θ°, η°) simply re-uses the guiding term solving machinery of P[1].","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"Now, in practice we will be working with recordings and not a single observation, so we will instead have:","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"θ° = ... # some new parameterization of the diffusion law\nηs° = [η1°,...] # some new parameterization of the observations\nP_new = map(i->GuidProp(P[i], θ°, ηs°[i]), 1:length(P))","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"and then instead of calling recompute_guiding_term! we should call a backward_filter! (which is just a wrapper function around multiple recompute_guiding_term!s that work on multiple GuidProp stacked together).","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"backward_filter!(P_new)","category":"page"},{"location":"manual/bffg/#","page":"BFFG algorithm","title":"BFFG algorithm","text":"That's it. Now, P_new has new parameters, has its guiding term re-computed to be compatible with those parameters and can be used for sampling.","category":"page"},{"location":"#GuidedProposals.jl-1","page":"Home","title":"GuidedProposals.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Efficient and user-friendly guided proposals in Julia. Introduced in M Schauer, F van der Meulen and H van Zanten Guided proposals for simulating multi-dimensional diffusion bridges (2017) arXiv.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Provides methods for efficient sampling of conditioned diffusions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Depending on your intended use of this package you might choose to start at different places:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a quick overview of GuidedProposals.jl's main functionality see Get started.\nFor a systematic introduction to all functionality introduced in this package see the Manual\nFor a didactic introduction to problems that can be solved using GuidedProposals.jl see the Tutorials\nIf you have a problem that you think can be addressed with this package, then check out the How-to guides to see if the answer is already there.","category":"page"}]
}
